{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/icarus/source/css/back-to-top.css","path":"css/back-to-top.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/insight.css","path":"css/insight.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/progressbar.css","path":"css/progressbar.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/search.css","path":"css/search.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/favicon.svg","path":"images/favicon.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/thumbnail.svg","path":"images/thumbnail.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/clipboard.js","path":"js/clipboard.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/back-to-top.js","path":"js/back-to-top.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"ae39518807c813cf6075bcdec722e38bc5e99769","modified":1561388847861},{"_id":"themes/icarus/_config.yml","hash":"d5f0da0e812601c05792c1dad1a9be08537bd6f6","modified":1553522491886},{"_id":"themes/icarus/.gitignore","hash":"542aaea07afe90211c6a45c90b7d6879a4503043","modified":1552747241175},{"_id":"themes/icarus/LICENSE","hash":"41f72cd544612bc4589c924c776422b800a4eff7","modified":1552747241175},{"_id":"themes/icarus/README.md","hash":"4409383fbd7422800049d6597e9b26aa8db66b66","modified":1552747241175},{"_id":"themes/icarus/package.json","hash":"4167e65682af257bdf8531a05730e6c42339996d","modified":1552747241191},{"_id":"themes/icarus/.DS_Store","hash":"7d54fc5236d9d890f1ef6c6fc2f466177cff4c8e","modified":1552819233495},{"_id":"source/_posts/.DS_Store","hash":"bb7a97ad4209dab01ee6a6d5129188230f34ff26","modified":1555337421583},{"_id":"source/_posts/2017-08-05-javascript基础之数组的操作.md","hash":"7ae36e2306f6b7e125a9332772607374b6504b35","modified":1553092519381},{"_id":"source/_posts/2018-01-11-一款精简的移动端上拉加载下拉刷新插件.md","hash":"e2ac72b14c25881c702189988b5be19569415eae","modified":1553092494324},{"_id":"source/_posts/2018-02-12-vue学习笔记之生命周期钩子函数.md","hash":"9809b47a79f1d916db07c4771a55adf3c76403c8","modified":1553092457464},{"_id":"source/_posts/2018-02-12-vue学习笔记之如何发送get post jsonp请求.md","hash":"52dec10a02985b8aad6faf2c8d8c2628f0f504f2","modified":1553441415250},{"_id":"source/_posts/2018-02-12-vue学习笔记之自定义按键修饰符.md","hash":"a46e84ec9339fc39083264c5bf70b93cdbc0921b","modified":1553092417215},{"_id":"source/_posts/2018-02-12-vue学习笔记之自定义全局和私有指令.md","hash":"734a81744690e43311b6877de61ace3cd12fb242","modified":1553092383242},{"_id":"source/_posts/2018-02-12-vue学习笔记之过渡类名实现动画.md","hash":"7a2a4759155af8413da857b452e8c4e103ffae79","modified":1553092481904},{"_id":"source/_posts/2018-02-19-Mint UI踩坑之路.md","hash":"1f8c2ab6db17eee8f1095f9925d852adba8b6071","modified":1553092307843},{"_id":"source/_posts/2018-02-19-charles连接手机抓包.md","hash":"28bcd23fff71cb3f751af16ff1f1fb7013463493","modified":1553092320260},{"_id":"source/_posts/2018-02-19-常用代码片段.md","hash":"21a6746050a2ee2194a10d48abe834ec9bc67f08","modified":1553092373101},{"_id":"source/_posts/2019-01-11-前后端交互之跨域问题-md.md","hash":"080ed824738dbbd32acbabe8cdaca610a9f05fc7","modified":1553091716376},{"_id":"source/_posts/2019-03-17-hello-md.md","hash":"6301b9178ab0fdd8037d4fd3be9dd1537ccdb7ca","modified":1552920127482},{"_id":"source/_posts/node-js学习笔记之入门-md.md","hash":"fd33968e774f940b76b7a5bab9e69454c33103f2","modified":1555336417209},{"_id":"source/_posts/2017-08-05-javascript基础之字符串操作.md","hash":"1535b64d8a550b6cd08ffd568317c4c460ea80ab","modified":1553092509731},{"_id":"source/_posts/java基本语法-md.md","hash":"551f634f16b606195205e3d7a305a540004d5bc2","modified":1560611811652},{"_id":"source/_posts/vue-node-md.md","hash":"613056524908f483e6b18a17a79282e902b4b890","modified":1553438872577},{"_id":"source/_posts/java基础-md.md","hash":"a51a14f34767a717f0bf25b6e53c710a5ef1a617","modified":1560356178228},{"_id":"source/_posts/vue学习笔记之vuex状态管理-md.md","hash":"7e0671de1eee823a6394786ff57e9212611f6d36","modified":1554619541677},{"_id":"themes/icarus/languages/en.yml","hash":"b69c91878f30937f50438ff64dffd3f6bf91bcf5","modified":1552747241180},{"_id":"themes/icarus/languages/es.yml","hash":"8827823e5b2ce967566854c9bfebc7c69098b4ac","modified":1552747241180},{"_id":"themes/icarus/languages/fr.yml","hash":"0017f93a5d491a9c0e55911cdc35316762c5a94e","modified":1552747241180},{"_id":"themes/icarus/languages/id.yml","hash":"92d2d19a62a17b6e99f82a014309bbf6c13c9ae8","modified":1552747241180},{"_id":"themes/icarus/languages/ja.yml","hash":"6eed7771de2353d71b720c6e605cceb3f230b12e","modified":1552747241180},{"_id":"themes/icarus/languages/ko.yml","hash":"06d2bb8b66f68f780218e0ba7edffe1e57fac268","modified":1552747241180},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"bcf5bc81ca855d26bbc3b3bfabc7d84429e74b85","modified":1552747241181},{"_id":"themes/icarus/languages/ru.yml","hash":"ba8b4f7d77eb1d1e28aa1f9107bd0bbbdc4cba99","modified":1552747241181},{"_id":"themes/icarus/languages/tr.yml","hash":"eff1c0b3d5c4b328f6dd74a195ff378c898f4d29","modified":1552747241181},{"_id":"themes/icarus/languages/vn.yml","hash":"6d9f4fabca711a6cb0a0efd72aa75c3641beb4a6","modified":1552747241181},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"804f6a1edee49bb6a5ecb8e9d14d3e93eaca37c0","modified":1552747241181},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"79fab0bff625634fb6bb6cadf9c547bd36226dcf","modified":1552747241181},{"_id":"themes/icarus/layout/category.ejs","hash":"bda344da0e6c03899f53abc20ae2a2efab5ab243","modified":1552747241182},{"_id":"themes/icarus/layout/categories.ejs","hash":"29d304f2b95a04fbc5e7529f9bdce9648e3545ef","modified":1552747241182},{"_id":"themes/icarus/layout/layout.ejs","hash":"da63c914247eba116ea5263bfc27a69e96f859b6","modified":1552747241185},{"_id":"themes/icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1552747241185},{"_id":"themes/icarus/layout/archive.ejs","hash":"64a81f4c6ca9517169413408d076371e8e09c63a","modified":1552747241182},{"_id":"themes/icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1552747241187},{"_id":"themes/icarus/layout/index.ejs","hash":"71120f41d019bf2866a5556747e5e671c8147f85","modified":1552747241185},{"_id":"themes/icarus/layout/tag.ejs","hash":"1feac7aa842882757a479b8ad427f6a72fce70c4","modified":1552747241189},{"_id":"themes/icarus/scripts/index.js","hash":"9203e2ba1f821d945edf20fc277f3c58d22bfd00","modified":1552747241191},{"_id":"themes/icarus/.git/config","hash":"965ef2ab67fe8b8aa4fb072307ee50d7cf6b31fe","modified":1552747241171},{"_id":"themes/icarus/layout/tags.ejs","hash":"0c527c6b72386f11c18e8aa5249be8c601e69906","modified":1552747241189},{"_id":"themes/icarus/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1552747241169},{"_id":"themes/icarus/.git/packed-refs","hash":"a8f4c47fe787bae0ce848e44936b0eb631abd634","modified":1552747241168},{"_id":"themes/icarus/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1552746792682},{"_id":"themes/icarus/source/.DS_Store","hash":"2585d845c2e7f1dd8f50bbe8265deb91fb5a845c","modified":1552819233494},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE.md","hash":"6b17b84116938367757928087a09dcb8489d06f6","modified":1552747241175},{"_id":"themes/icarus/.git/index","hash":"ae9ae098c0e3e0de6f0f42d374322f4d6e2fb604","modified":1552788914954},{"_id":"themes/icarus/includes/common/ConfigValidator.js","hash":"cd3cd12bc042b401825fd7bfd9a6434c8b14e092","modified":1552747241175},{"_id":"themes/icarus/includes/common/ConfigGenerator.js","hash":"451397efc7808787419fa3eb6b043c0bd8bbdf30","modified":1552747241175},{"_id":"themes/icarus/includes/common/utils.js","hash":"c0aeaeb57a42bcc71a92da2249762f91abd83ffe","modified":1552747241176},{"_id":"themes/icarus/includes/filters/highlight.js","hash":"19a4dcd2dee7388544b57e473cfb0fc9eea9623e","modified":1552747241176},{"_id":"themes/icarus/includes/generators/categories.js","hash":"7cb370ac53a05d6b1b9203579716c0ca83d35c36","modified":1552747241176},{"_id":"themes/icarus/includes/generators/category.js","hash":"313e170e55d74526c4e1be7181ef7a21439147c9","modified":1552747241176},{"_id":"themes/icarus/includes/generators/insight.js","hash":"c4b981443927b87cc14a3a583029e13f819d6d71","modified":1552747241176},{"_id":"themes/icarus/includes/generators/tags.js","hash":"8195322c208706427a1cf56361669dca4d86f6f1","modified":1552747241176},{"_id":"themes/icarus/includes/helpers/cdn.js","hash":"7d34ea6400cb3611c374c135304abcb65ef291b7","modified":1552747241176},{"_id":"themes/icarus/includes/helpers/config.js","hash":"173e02987e7a7d5df1e686f6ee4edd8cf494bdd3","modified":1552747241177},{"_id":"themes/icarus/includes/helpers/layout.js","hash":"afdf5e9704cfc087526b4a0403fe7eb04f22190e","modified":1552747241177},{"_id":"themes/icarus/includes/helpers/override.js","hash":"726cf99612fd060753d9da08db2776aec1802e20","modified":1552747241177},{"_id":"themes/icarus/includes/helpers/page.js","hash":"25aeed6449ca381661cec528fe96bbb993026ca9","modified":1552747241177},{"_id":"themes/icarus/includes/helpers/site.js","hash":"f154ddb0dac79fd28ced2b518f8052b42555d0c9","modified":1552747241177},{"_id":"themes/icarus/includes/specs/article.spec.js","hash":"a805c1a6f03ccb07d73512aef40d38541ddbb0eb","modified":1552747241177},{"_id":"themes/icarus/includes/specs/comment.spec.js","hash":"02af67eb87482028b223299b20a129756b1c122b","modified":1552747241177},{"_id":"themes/icarus/includes/specs/config.spec.js","hash":"7a9bac384a73cf9f39173fdb2dfc2813784d8891","modified":1552747241178},{"_id":"themes/icarus/includes/specs/donate.spec.js","hash":"639b405c9e5dac04c2dc168c2754e50a5c13d197","modified":1552747241178},{"_id":"themes/icarus/includes/specs/footer.spec.js","hash":"49fabe9c03f3124f0253fa1ee3e69328373ad117","modified":1552747241178},{"_id":"themes/icarus/includes/specs/icon_link.spec.js","hash":"f2a83ac5ccb74fc6f3dfbd25430e142297d8491c","modified":1552747241178},{"_id":"themes/icarus/includes/specs/meta.spec.js","hash":"70abe77d3664176ec977316522014ce7e0aa439d","modified":1552747241178},{"_id":"themes/icarus/includes/specs/navbar.spec.js","hash":"67ebd05fb378439a094a7906f4ea04fbedd8c1b5","modified":1552747241178},{"_id":"themes/icarus/includes/specs/plugins.spec.js","hash":"3db2046311dd0392aed0ba2d81b51a081131f1de","modified":1552747241178},{"_id":"themes/icarus/includes/specs/providers.spec.js","hash":"e29473155a35f391fbc53349bdc256cb7600855e","modified":1552747241179},{"_id":"themes/icarus/includes/specs/search.spec.js","hash":"d981ad203a2002c35d710d33e304f9e99f31cab0","modified":1552747241179},{"_id":"themes/icarus/includes/specs/share.spec.js","hash":"6c04cccec13a656189ab2d917d69d059027d0343","modified":1552747241179},{"_id":"themes/icarus/includes/specs/sidebar.spec.js","hash":"bd500be763486918894e731ce14bc9c4047fb76d","modified":1552747241179},{"_id":"themes/icarus/includes/specs/widgets.spec.js","hash":"eeeaae3ed079033788b19e172cd1f83c5ca8bc4f","modified":1552747241179},{"_id":"themes/icarus/includes/tasks/check_config.js","hash":"ce7626d643737c90dee6b75435ccdec26b89dacf","modified":1552747241179},{"_id":"themes/icarus/includes/tasks/check_deps.js","hash":"cfc357f27116d1b9285a3b0bec35c3e89ae73711","modified":1552747241179},{"_id":"themes/icarus/includes/tasks/welcome.js","hash":"00d1ef8c9609552b82e9a5140b838a9057c59508","modified":1552747241180},{"_id":"themes/icarus/layout/common/head.ejs","hash":"bd72ffd5942bb2fd18319d551bbaa59647e33f3c","modified":1552747241184},{"_id":"themes/icarus/layout/common/paginator.ejs","hash":"7837d80b27f166161b3deeffb571680025c7d723","modified":1552747241184},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"9e57d97a52ad358b5f38cf87a3fda356d2094b6d","modified":1552747241184},{"_id":"themes/icarus/layout/common/article.ejs","hash":"76e4b72b62cf3e34227980aa8c7161ee27b57a7a","modified":1552747241183},{"_id":"themes/icarus/layout/common/navbar.ejs","hash":"5082ea45df0f79f955143177287d92bcf3832fcf","modified":1552747241184},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"5414d6bfbf88efa7e72ccf7e44a79d0378ddeb77","modified":1552747241184},{"_id":"themes/icarus/layout/common/widget.ejs","hash":"5417af9f208d2fb5aaeb96031caa261e9683557c","modified":1552747241184},{"_id":"themes/icarus/layout/donate/patreon.ejs","hash":"8e52a9c28ffaf4b0b786a20977b848c5f60f2274","modified":1552747241185},{"_id":"themes/icarus/layout/donate/wechat.ejs","hash":"051b873e1fc28c1d7c2d6443991b6a2f43813e6b","modified":1552747241185},{"_id":"themes/icarus/layout/donate/paypal.ejs","hash":"3975dee39f9378975b9c10f37d118ad7cb6f5bf6","modified":1552747241185},{"_id":"themes/icarus/layout/donate/alipay.ejs","hash":"3290058879973e403a05472a0fe2ac0219d5b961","modified":1552747241185},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"eb66e313ad43ec4424b2d75bae94e5c8a7568428","modified":1552747241186},{"_id":"themes/icarus/layout/plugin/animejs.ejs","hash":"198062ef863c96aa4d6a8225d575afcb60dfb1d1","modified":1552747241186},{"_id":"themes/icarus/layout/plugin/back-to-top.ejs","hash":"79d1118a3d3ebc521ffce452b986b504f0e7d6b7","modified":1552747241186},{"_id":"themes/icarus/layout/plugin/busuanzi.ejs","hash":"205dedf8f97e328bb3182dc8daebd2e2b2204aca","modified":1552747241186},{"_id":"themes/icarus/layout/plugin/clipboard.ejs","hash":"8662ed9c211f3993b93eedcf5e41c2a1ddbede57","modified":1552747241186},{"_id":"themes/icarus/layout/plugin/gallery.ejs","hash":"ad68fafd923747d6b7c1b5873d00989d1639678c","modified":1552747241186},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"282cecb28ac458b71b56cf429c72ffac0f820199","modified":1552747241187},{"_id":"themes/icarus/layout/plugin/hotjar.ejs","hash":"2b97737d802984750a7b4461fcf68818a57a2439","modified":1552747241187},{"_id":"themes/icarus/layout/plugin/mathjax.ejs","hash":"667aabb6b9cb4d707b37975af794d4a3c66b5264","modified":1552747241187},{"_id":"themes/icarus/layout/plugin/outdated-browser.ejs","hash":"fe051093893c64c8575bcc67dc1c146d409e8e80","modified":1552747241187},{"_id":"themes/icarus/layout/plugin/progressbar.ejs","hash":"e594ed6705bccbef27f49d84b6153f6443efbecd","modified":1552747241187},{"_id":"themes/icarus/layout/comment/changyan.ejs","hash":"9ccc7ec354b968e60bdcfcd1dba451d38de61f12","modified":1552747241182},{"_id":"themes/icarus/layout/comment/gitalk.ejs","hash":"ef01396e64ab4f6e62155f0b357bcd903138d611","modified":1552747241182},{"_id":"themes/icarus/layout/comment/facebook.ejs","hash":"b38ea86a1cae48f671501af74d7f109f63fb3d72","modified":1552747241182},{"_id":"themes/icarus/layout/comment/gitment.ejs","hash":"033fb890dc1de71f7d3b97061d0d75f4564bd09a","modified":1552747241183},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"b5fff46e453d58baa20028a47fd85923494bb85c","modified":1552747241182},{"_id":"themes/icarus/layout/comment/valine.ejs","hash":"a29cf2e69f66a37ddcec8343c60af1e676dcb77d","modified":1552747241183},{"_id":"themes/icarus/layout/comment/isso.ejs","hash":"cc6a43bd24be764086f88ad7c5c97ff04df87e0b","modified":1552747241183},{"_id":"themes/icarus/layout/comment/livere.ejs","hash":"12ff9a345f6bba2f732f592e39508c2afde89b00","modified":1552747241183},{"_id":"themes/icarus/layout/share/addthis.ejs","hash":"f1c5f337333009d5f00dfbac4864a16ef8f9cb8d","modified":1552747241188},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"04cb247d8c83ca7c5b52f3b11bb3ac155b1bc3ab","modified":1552747241188},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"f14c8084b7ee16a091f0bd2ae9039e3bfff7e7b7","modified":1552747241189},{"_id":"themes/icarus/layout/share/sharethis.ejs","hash":"4f2c40f790f3be0a4e79db04f02ea41ba2f4d4c0","modified":1552747241189},{"_id":"themes/icarus/layout/share/sharejs.ejs","hash":"65d08316cc479910ea4f526cd1c299d0104daf7f","modified":1552747241189},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"850aa91778100d693a52b10eaa8586c8e3215ee6","modified":1552747241188},{"_id":"themes/icarus/layout/search/google-cse.ejs","hash":"4b881a99325a6a0cebf97ac53e09d8fc67f87d29","modified":1552747241188},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"9a27db2a007582ceee7ca4b1eebddbd456893568","modified":1552747241188},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"eb738a2ac2935ce7a542964d90088613b281dd15","modified":1552747241189},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"2b707fd65c94b00d8b4c6755fbc6c19709f3d49a","modified":1552747241190},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"c2a9f2211a21a168c54b0563cdfd58bd25fa39fe","modified":1552747241190},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"2166f3190e47bf4746775b5d16654564a88c2041","modified":1552747241190},{"_id":"themes/icarus/layout/widget/profile.ejs","hash":"f42f9c2ab99905ba0bec913405e5c4261c44ddae","modified":1552747241190},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"d32e7c56e8e2074da16d9141f9a597841d28d07d","modified":1552747241190},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"8c5b8020ca776cc3ebbc7b723915f3173efc28d4","modified":1552747241190},{"_id":"themes/icarus/layout/widget/toc.ejs","hash":"bdc6f22602cdabe7c740f1818e0681ff8508fb64","modified":1552747241190},{"_id":"themes/icarus/.git/logs/HEAD","hash":"daeaf06424d0a4076bbc2dc1679884c97fc35af1","modified":1552747241170},{"_id":"themes/icarus/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1552746792681},{"_id":"themes/icarus/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1552746792682},{"_id":"themes/icarus/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1552746792682},{"_id":"themes/icarus/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1552746792682},{"_id":"themes/icarus/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1552746792682},{"_id":"themes/icarus/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1552746792683},{"_id":"themes/icarus/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1552746792683},{"_id":"themes/icarus/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1552746792683},{"_id":"themes/icarus/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1552746792682},{"_id":"themes/icarus/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1552746792683},{"_id":"themes/icarus/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1552746792682},{"_id":"themes/icarus/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1552746792683},{"_id":"themes/icarus/source/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1552747241191},{"_id":"themes/icarus/source/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1552747241191},{"_id":"themes/icarus/source/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1552747241191},{"_id":"themes/icarus/source/css/search.css","hash":"c1cb306e075386517ac15bf4ef37c647d37ec6b5","modified":1552747241192},{"_id":"themes/icarus/source/images/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1552747241192},{"_id":"themes/icarus/source/images/.DS_Store","hash":"55f584e974412341472026139afaf0f8ded05302","modified":1552820771357},{"_id":"themes/icarus/source/css/style.styl","hash":"efd8abc2609f08800d5642ba5f0ffc430722e0a5","modified":1552747241192},{"_id":"themes/icarus/source/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1552747241193},{"_id":"themes/icarus/source/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1552747241192},{"_id":"themes/icarus/source/images/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1552747241192},{"_id":"themes/icarus/source/images/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1552747241193},{"_id":"themes/icarus/source/js/clipboard.js","hash":"6fdd602268727744b6b2c8ad79d684aab3cffda5","modified":1552747241193},{"_id":"themes/icarus/source/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1552747241193},{"_id":"themes/icarus/source/js/gallery.js","hash":"88b23abfc3b519413be54533ed0f39e0c68fcdd1","modified":1552747241193},{"_id":"themes/icarus/source/js/main.js","hash":"3357a1798a994afad0a849a679ca2ed6e0ce2424","modified":1552747241194},{"_id":"themes/icarus/source/images/avatar.jpeg","hash":"e86e47784942af2a188ff5f366187644476c69fa","modified":1555742207040},{"_id":"themes/icarus/source/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1552747241193},{"_id":"themes/icarus/.git/refs/heads/master","hash":"23d86d7031547e85d9d033db5d2b3834b75cb241","modified":1552747241170},{"_id":"themes/icarus/.git/objects/pack/pack-4fceac76a571a769480f6481b41f0f67c97b258e.idx","hash":"08c208dd6f45176645a65c842a2c0411b7573c3c","modified":1552747241156},{"_id":"themes/icarus/.git/logs/refs/heads/master","hash":"daeaf06424d0a4076bbc2dc1679884c97fc35af1","modified":1552747241170},{"_id":"themes/icarus/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1552747241169},{"_id":"themes/icarus/.git/logs/refs/remotes/origin/HEAD","hash":"daeaf06424d0a4076bbc2dc1679884c97fc35af1","modified":1552747241169},{"_id":"themes/icarus/.git/objects/pack/pack-4fceac76a571a769480f6481b41f0f67c97b258e.pack","hash":"56946073aebb6e9c585b8c12726023920beceec6","modified":1552747241155}],"Category":[{"name":"vue","_id":"cjxaj7gux000xgp9a1s42dgbd"}],"Data":[],"Page":[],"Post":[{"title":"dropload.js使用介绍","date":"2018-01-11T11:13:13.000Z","_content":"## dropload.js \n##### 一款精简的移动端上拉加载下拉刷新插件\n###### 最近在做一个移动端上拉加载下拉刷新功能，无意中发现了此插件，使用简单方便，奈何坑太多！\n[点击查看dropload.js相关介绍及demo下载](https://github.com/ximan/dropload \"点此下载\")\n\n####使用介绍：\n\t\n<!--more-->\n1. 将下载好的`dropload.js`插件中的`dropload.js，dropload.css`引入页面当中，**注意**引入`dropload.js`之前，要保证已经引入`Jquery 1.7`及`Zepto`文件。\n2. ","source":"_posts/2018-01-11-一款精简的移动端上拉加载下拉刷新插件.md","raw":"---\ntitle: dropload.js使用介绍\ndate: 2018-01-11 19:13:13\ntags: js\n---\n## dropload.js \n##### 一款精简的移动端上拉加载下拉刷新插件\n###### 最近在做一个移动端上拉加载下拉刷新功能，无意中发现了此插件，使用简单方便，奈何坑太多！\n[点击查看dropload.js相关介绍及demo下载](https://github.com/ximan/dropload \"点此下载\")\n\n####使用介绍：\n\t\n<!--more-->\n1. 将下载好的`dropload.js`插件中的`dropload.js，dropload.css`引入页面当中，**注意**引入`dropload.js`之前，要保证已经引入`Jquery 1.7`及`Zepto`文件。\n2. ","slug":"2018-01-11-一款精简的移动端上拉加载下拉刷新插件","published":1,"updated":"2019-03-20T14:34:54.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7gu40000gp9aibmk4u8l","content":"<h2 id=\"dropload-js\"><a href=\"#dropload-js\" class=\"headerlink\" title=\"dropload.js\"></a>dropload.js</h2><h5 id=\"一款精简的移动端上拉加载下拉刷新插件\"><a href=\"#一款精简的移动端上拉加载下拉刷新插件\" class=\"headerlink\" title=\"一款精简的移动端上拉加载下拉刷新插件\"></a>一款精简的移动端上拉加载下拉刷新插件</h5><h6 id=\"最近在做一个移动端上拉加载下拉刷新功能，无意中发现了此插件，使用简单方便，奈何坑太多！\"><a href=\"#最近在做一个移动端上拉加载下拉刷新功能，无意中发现了此插件，使用简单方便，奈何坑太多！\" class=\"headerlink\" title=\"最近在做一个移动端上拉加载下拉刷新功能，无意中发现了此插件，使用简单方便，奈何坑太多！\"></a>最近在做一个移动端上拉加载下拉刷新功能，无意中发现了此插件，使用简单方便，奈何坑太多！</h6><p><a href=\"https://github.com/ximan/dropload\" title=\"点此下载\" target=\"_blank\" rel=\"noopener\">点击查看dropload.js相关介绍及demo下载</a></p>\n<p>####使用介绍：</p>\n<a id=\"more\"></a>\n<ol>\n<li>将下载好的<code>dropload.js</code>插件中的<code>dropload.js，dropload.css</code>引入页面当中，<strong>注意</strong>引入<code>dropload.js</code>之前，要保证已经引入<code>Jquery 1.7</code>及<code>Zepto</code>文件。</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"dropload-js\"><a href=\"#dropload-js\" class=\"headerlink\" title=\"dropload.js\"></a>dropload.js</h2><h5 id=\"一款精简的移动端上拉加载下拉刷新插件\"><a href=\"#一款精简的移动端上拉加载下拉刷新插件\" class=\"headerlink\" title=\"一款精简的移动端上拉加载下拉刷新插件\"></a>一款精简的移动端上拉加载下拉刷新插件</h5><h6 id=\"最近在做一个移动端上拉加载下拉刷新功能，无意中发现了此插件，使用简单方便，奈何坑太多！\"><a href=\"#最近在做一个移动端上拉加载下拉刷新功能，无意中发现了此插件，使用简单方便，奈何坑太多！\" class=\"headerlink\" title=\"最近在做一个移动端上拉加载下拉刷新功能，无意中发现了此插件，使用简单方便，奈何坑太多！\"></a>最近在做一个移动端上拉加载下拉刷新功能，无意中发现了此插件，使用简单方便，奈何坑太多！</h6><p><a href=\"https://github.com/ximan/dropload\" title=\"点此下载\" target=\"_blank\" rel=\"noopener\">点击查看dropload.js相关介绍及demo下载</a></p>\n<p>####使用介绍：</p>","more":"<ol>\n<li>将下载好的<code>dropload.js</code>插件中的<code>dropload.js，dropload.css</code>引入页面当中，<strong>注意</strong>引入<code>dropload.js</code>之前，要保证已经引入<code>Jquery 1.7</code>及<code>Zepto</code>文件。</li>\n<li></li>\n</ol>"},{"title":"vue生命周期","date":"2018-02-12T11:13:13.000Z","_content":"#### vue生命周期\n[生命周期图示](https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA):\n\n<!--more-->\n\n1. vue实例创建阶段的四个函数\n\n\t\tbeforeCreated () {\n\t\t\t// 此函数表示实例完全被创建出来之前，会执行它\n\t\t\t// 注意： 在此生命周期函数执行的时候，data和methods中的数据还没有被初始化，故不能调用对data中的数据进行修改及调用methods中的方法\n\t\t}\n\t\n\t\tcreated () {\n\t\t\t// 在此生命周期函数执行时，data和methods都已经初始化好了\n\t\t\t// 如果要调用 methods 中的方法，或者操作 data 中的数据，最早也只能在此函数中进行操作\n\t\t}\n\t\n\t\tbeforeMount () {\n\t\t\t// 此函数表明，模板已经在内存中编辑完成了，但是尚未挂载到页面中\n\t\t\t// 在此函数执行的时候，页面中的元素，还没有被真正的渲染\n\t\t}\n\t\n\t\tmounted () {\n\t\t\t// 此函数表示，内存中的数据，已经真实的挂载到了页面中，用户已经可以看到真实的渲染好的页面了\n\t\t\t// mounted是实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的躺在内存中，一动不动\n\t\t\t// 此时，组件已经脱离了创建阶段，进入到运行阶段\n\t\t}\n\n2. vue实例运行时的函数\n\n\t\tbeforeUpdate () {\n\t\t\t// 当 data 中的数据发生变化时，会执行此函数，当执行此函数时，页面中显示的数据，依然是 data 更新之前的旧数据，但 data 在内存中的数据已经是最新的了，页面尚未和最新的数据保持同步\n\t\t}\n\n\t\tupdated () {\n\t\t\t// 此时页面和 data 数据已经保持同步了\n\t\t}\n\n3. vue实例销毁时的函数\n\n\t\tbeforeDestory () {\n\t\t\t// 当执行此函数时，就表示Vue实例已经从运行阶段，进入到销毁阶段，\n\t\t\t// 当执行此函数时，实例上data中所有的数据和methods中的方法，一级指令，过滤器...都处于可用状态，还没有这正执行销毁过程\n\t\t\t// 此方法中，一般做一些诸如定时器等的销毁收尾工作\n\t\t}\n\n\t\tdestoryed () {\n\t\t\t// 当执行此函数时，组件已经被完全销毁了，此时，组件中所有的数据，方法，指令，过滤器...都已经不可用了\n\t\t}","source":"_posts/2018-02-12-vue学习笔记之生命周期钩子函数.md","raw":"---\ntitle: vue生命周期\ndate: 2018-02-12 19:13:13\ntags: vue\n---\n#### vue生命周期\n[生命周期图示](https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA):\n\n<!--more-->\n\n1. vue实例创建阶段的四个函数\n\n\t\tbeforeCreated () {\n\t\t\t// 此函数表示实例完全被创建出来之前，会执行它\n\t\t\t// 注意： 在此生命周期函数执行的时候，data和methods中的数据还没有被初始化，故不能调用对data中的数据进行修改及调用methods中的方法\n\t\t}\n\t\n\t\tcreated () {\n\t\t\t// 在此生命周期函数执行时，data和methods都已经初始化好了\n\t\t\t// 如果要调用 methods 中的方法，或者操作 data 中的数据，最早也只能在此函数中进行操作\n\t\t}\n\t\n\t\tbeforeMount () {\n\t\t\t// 此函数表明，模板已经在内存中编辑完成了，但是尚未挂载到页面中\n\t\t\t// 在此函数执行的时候，页面中的元素，还没有被真正的渲染\n\t\t}\n\t\n\t\tmounted () {\n\t\t\t// 此函数表示，内存中的数据，已经真实的挂载到了页面中，用户已经可以看到真实的渲染好的页面了\n\t\t\t// mounted是实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的躺在内存中，一动不动\n\t\t\t// 此时，组件已经脱离了创建阶段，进入到运行阶段\n\t\t}\n\n2. vue实例运行时的函数\n\n\t\tbeforeUpdate () {\n\t\t\t// 当 data 中的数据发生变化时，会执行此函数，当执行此函数时，页面中显示的数据，依然是 data 更新之前的旧数据，但 data 在内存中的数据已经是最新的了，页面尚未和最新的数据保持同步\n\t\t}\n\n\t\tupdated () {\n\t\t\t// 此时页面和 data 数据已经保持同步了\n\t\t}\n\n3. vue实例销毁时的函数\n\n\t\tbeforeDestory () {\n\t\t\t// 当执行此函数时，就表示Vue实例已经从运行阶段，进入到销毁阶段，\n\t\t\t// 当执行此函数时，实例上data中所有的数据和methods中的方法，一级指令，过滤器...都处于可用状态，还没有这正执行销毁过程\n\t\t\t// 此方法中，一般做一些诸如定时器等的销毁收尾工作\n\t\t}\n\n\t\tdestoryed () {\n\t\t\t// 当执行此函数时，组件已经被完全销毁了，此时，组件中所有的数据，方法，指令，过滤器...都已经不可用了\n\t\t}","slug":"2018-02-12-vue学习笔记之生命周期钩子函数","published":1,"updated":"2019-03-20T14:34:17.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7gua0001gp9aqa1ufgdu","content":"<h4 id=\"vue生命周期\"><a href=\"#vue生命周期\" class=\"headerlink\" title=\"vue生命周期\"></a>vue生命周期</h4><p><a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\" target=\"_blank\" rel=\"noopener\">生命周期图示</a>:</p>\n<a id=\"more\"></a>\n<ol>\n<li><p>vue实例创建阶段的四个函数</p>\n<pre><code>beforeCreated () {\n    // 此函数表示实例完全被创建出来之前，会执行它\n    // 注意： 在此生命周期函数执行的时候，data和methods中的数据还没有被初始化，故不能调用对data中的数据进行修改及调用methods中的方法\n}\n\ncreated () {\n    // 在此生命周期函数执行时，data和methods都已经初始化好了\n    // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早也只能在此函数中进行操作\n}\n\nbeforeMount () {\n    // 此函数表明，模板已经在内存中编辑完成了，但是尚未挂载到页面中\n    // 在此函数执行的时候，页面中的元素，还没有被真正的渲染\n}\n\nmounted () {\n    // 此函数表示，内存中的数据，已经真实的挂载到了页面中，用户已经可以看到真实的渲染好的页面了\n    // mounted是实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的躺在内存中，一动不动\n    // 此时，组件已经脱离了创建阶段，进入到运行阶段\n}\n</code></pre></li>\n<li><p>vue实例运行时的函数</p>\n<pre><code>beforeUpdate () {\n    // 当 data 中的数据发生变化时，会执行此函数，当执行此函数时，页面中显示的数据，依然是 data 更新之前的旧数据，但 data 在内存中的数据已经是最新的了，页面尚未和最新的数据保持同步\n}\n\nupdated () {\n    // 此时页面和 data 数据已经保持同步了\n}\n</code></pre></li>\n<li><p>vue实例销毁时的函数</p>\n<pre><code>beforeDestory () {\n    // 当执行此函数时，就表示Vue实例已经从运行阶段，进入到销毁阶段，\n    // 当执行此函数时，实例上data中所有的数据和methods中的方法，一级指令，过滤器...都处于可用状态，还没有这正执行销毁过程\n    // 此方法中，一般做一些诸如定时器等的销毁收尾工作\n}\n\ndestoryed () {\n    // 当执行此函数时，组件已经被完全销毁了，此时，组件中所有的数据，方法，指令，过滤器...都已经不可用了\n}\n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"vue生命周期\"><a href=\"#vue生命周期\" class=\"headerlink\" title=\"vue生命周期\"></a>vue生命周期</h4><p><a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\" target=\"_blank\" rel=\"noopener\">生命周期图示</a>:</p>","more":"<ol>\n<li><p>vue实例创建阶段的四个函数</p>\n<pre><code>beforeCreated () {\n    // 此函数表示实例完全被创建出来之前，会执行它\n    // 注意： 在此生命周期函数执行的时候，data和methods中的数据还没有被初始化，故不能调用对data中的数据进行修改及调用methods中的方法\n}\n\ncreated () {\n    // 在此生命周期函数执行时，data和methods都已经初始化好了\n    // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早也只能在此函数中进行操作\n}\n\nbeforeMount () {\n    // 此函数表明，模板已经在内存中编辑完成了，但是尚未挂载到页面中\n    // 在此函数执行的时候，页面中的元素，还没有被真正的渲染\n}\n\nmounted () {\n    // 此函数表示，内存中的数据，已经真实的挂载到了页面中，用户已经可以看到真实的渲染好的页面了\n    // mounted是实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的躺在内存中，一动不动\n    // 此时，组件已经脱离了创建阶段，进入到运行阶段\n}\n</code></pre></li>\n<li><p>vue实例运行时的函数</p>\n<pre><code>beforeUpdate () {\n    // 当 data 中的数据发生变化时，会执行此函数，当执行此函数时，页面中显示的数据，依然是 data 更新之前的旧数据，但 data 在内存中的数据已经是最新的了，页面尚未和最新的数据保持同步\n}\n\nupdated () {\n    // 此时页面和 data 数据已经保持同步了\n}\n</code></pre></li>\n<li><p>vue实例销毁时的函数</p>\n<pre><code>beforeDestory () {\n    // 当执行此函数时，就表示Vue实例已经从运行阶段，进入到销毁阶段，\n    // 当执行此函数时，实例上data中所有的数据和methods中的方法，一级指令，过滤器...都处于可用状态，还没有这正执行销毁过程\n    // 此方法中，一般做一些诸如定时器等的销毁收尾工作\n}\n\ndestoryed () {\n    // 当执行此函数时，组件已经被完全销毁了，此时，组件中所有的数据，方法，指令，过滤器...都已经不可用了\n}\n</code></pre></li>\n</ol>"},{"title":"vue发送get post jsonp请求","date":"2018-02-12T11:13:13.000Z","_content":"#### 1. 使用 [vue-resource](https://github.com/pagekit/vue-resource) 发送get、 post、 jsonp请求\n> 官方已不再维护\n\n[github提供的vue-ersource请求测试地址](https://github.com/typicode/json-server)\n\n+ 使用 vue-resource 发送 get 请求\n\n<!--more-->\n\n\tthis.$http.get('/someUrl').then(response => {\n\t\t// get body data\n\t\tconsole.log(response.body)\n\n\t}, error => {\n\t\t// error callback\n\n\t})\n\n+ 使用 vue-resource 发送 post 请求\n\n\t\tthis.$http.post('/someUrl', {body}, {config}).then(response => {\n\t\t\t// 默认发起的 post 请求，默认没有表单格式，所以有的服务器处理不了\n\t\t\t// 通过查阅文档发现，通过 post 方法的第三个参数，{ emulateJSON：true }设置提交的内容为普通表单数据格式\n\t\t\tconsole.log(response.body)\n\t\n\t\t}, error => {\n\t\t\t// error callback\n\t\t})\n\t\n\t\n+ 使用 vue-resource 发送 jsonp 请求\n\n\t\tthis.$http.jsonp('/someUrl', {config}).then(response => {\n\t\t\tconsole.log(response.body)\n\t\n\t\t}, error => {\n\t\t\t// error callback\n\t\t})","source":"_posts/2018-02-12-vue学习笔记之如何发送get post jsonp请求.md","raw":"---\ntitle: vue发送get post jsonp请求\ndate: 2018-02-12 19:13:13\ntags: vue\n---\n#### 1. 使用 [vue-resource](https://github.com/pagekit/vue-resource) 发送get、 post、 jsonp请求\n> 官方已不再维护\n\n[github提供的vue-ersource请求测试地址](https://github.com/typicode/json-server)\n\n+ 使用 vue-resource 发送 get 请求\n\n<!--more-->\n\n\tthis.$http.get('/someUrl').then(response => {\n\t\t// get body data\n\t\tconsole.log(response.body)\n\n\t}, error => {\n\t\t// error callback\n\n\t})\n\n+ 使用 vue-resource 发送 post 请求\n\n\t\tthis.$http.post('/someUrl', {body}, {config}).then(response => {\n\t\t\t// 默认发起的 post 请求，默认没有表单格式，所以有的服务器处理不了\n\t\t\t// 通过查阅文档发现，通过 post 方法的第三个参数，{ emulateJSON：true }设置提交的内容为普通表单数据格式\n\t\t\tconsole.log(response.body)\n\t\n\t\t}, error => {\n\t\t\t// error callback\n\t\t})\n\t\n\t\n+ 使用 vue-resource 发送 jsonp 请求\n\n\t\tthis.$http.jsonp('/someUrl', {config}).then(response => {\n\t\t\tconsole.log(response.body)\n\t\n\t\t}, error => {\n\t\t\t// error callback\n\t\t})","slug":"2018-02-12-vue学习笔记之如何发送get post jsonp请求","published":1,"updated":"2019-03-24T15:30:15.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7guf0003gp9avayvbjzy","content":"<h4 id=\"1-使用-vue-resource-发送get、-post、-jsonp请求\"><a href=\"#1-使用-vue-resource-发送get、-post、-jsonp请求\" class=\"headerlink\" title=\"1. 使用 vue-resource 发送get、 post、 jsonp请求\"></a>1. 使用 <a href=\"https://github.com/pagekit/vue-resource\" target=\"_blank\" rel=\"noopener\">vue-resource</a> 发送get、 post、 jsonp请求</h4><blockquote>\n<p>官方已不再维护</p>\n</blockquote>\n<p><a href=\"https://github.com/typicode/json-server\" target=\"_blank\" rel=\"noopener\">github提供的vue-ersource请求测试地址</a></p>\n<ul>\n<li>使用 vue-resource 发送 get 请求</li>\n</ul>\n<a id=\"more\"></a>\n<pre><code>this.$http.get(&apos;/someUrl&apos;).then(response =&gt; {\n    // get body data\n    console.log(response.body)\n\n}, error =&gt; {\n    // error callback\n\n})\n</code></pre><ul>\n<li><p>使用 vue-resource 发送 post 请求</p>\n<pre><code>this.$http.post(&apos;/someUrl&apos;, {body}, {config}).then(response =&gt; {\n    // 默认发起的 post 请求，默认没有表单格式，所以有的服务器处理不了\n    // 通过查阅文档发现，通过 post 方法的第三个参数，{ emulateJSON：true }设置提交的内容为普通表单数据格式\n    console.log(response.body)\n\n}, error =&gt; {\n    // error callback\n})\n</code></pre></li>\n</ul>\n<ul>\n<li><p>使用 vue-resource 发送 jsonp 请求</p>\n<pre><code>this.$http.jsonp(&apos;/someUrl&apos;, {config}).then(response =&gt; {\n    console.log(response.body)\n\n}, error =&gt; {\n    // error callback\n})\n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-使用-vue-resource-发送get、-post、-jsonp请求\"><a href=\"#1-使用-vue-resource-发送get、-post、-jsonp请求\" class=\"headerlink\" title=\"1. 使用 vue-resource 发送get、 post、 jsonp请求\"></a>1. 使用 <a href=\"https://github.com/pagekit/vue-resource\" target=\"_blank\" rel=\"noopener\">vue-resource</a> 发送get、 post、 jsonp请求</h4><blockquote>\n<p>官方已不再维护</p>\n</blockquote>\n<p><a href=\"https://github.com/typicode/json-server\" target=\"_blank\" rel=\"noopener\">github提供的vue-ersource请求测试地址</a></p>\n<ul>\n<li>使用 vue-resource 发送 get 请求</li>\n</ul>","more":"<pre><code>this.$http.get(&apos;/someUrl&apos;).then(response =&gt; {\n    // get body data\n    console.log(response.body)\n\n}, error =&gt; {\n    // error callback\n\n})\n</code></pre><ul>\n<li><p>使用 vue-resource 发送 post 请求</p>\n<pre><code>this.$http.post(&apos;/someUrl&apos;, {body}, {config}).then(response =&gt; {\n    // 默认发起的 post 请求，默认没有表单格式，所以有的服务器处理不了\n    // 通过查阅文档发现，通过 post 方法的第三个参数，{ emulateJSON：true }设置提交的内容为普通表单数据格式\n    console.log(response.body)\n\n}, error =&gt; {\n    // error callback\n})\n</code></pre></li>\n</ul>\n<ul>\n<li><p>使用 vue-resource 发送 jsonp 请求</p>\n<pre><code>this.$http.jsonp(&apos;/someUrl&apos;, {config}).then(response =&gt; {\n    console.log(response.body)\n\n}, error =&gt; {\n    // error callback\n})\n</code></pre></li>\n</ul>"},{"title":"自定义按键修饰符","date":"2018-02-12T11:13:13.000Z","_content":"#### 自定义按键修饰符\n[语法](https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6)： \n> Vue.config.keyCodes.xxx = xxx对应的keyCode值\n\n<!--more-->\n\n我们知道，vue为我们提供了部分“见名知意”的[按键修饰符](https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6)，使用方法如下：\n\n\t<input type=\"button\" value=\"保存\" @keyup.enter=\"save\"/> // 点击enter触发 save() 方法\n\t<input type=\"button\" value=\"保存\" @keyup.13=\"save\"/> // 点击enter触发 save() 方法\n\n除此之外，我们想要使用vue尚未提供的按键修饰符，只能使用按键对应的keyCode值，不能很好的见名知意，例如，我们想按f2键来执行一个`save()`方法，只能查询f2对应的[keyCode](http://www.cnblogs.com/wuhua1/p/6686237.html)值，使用如下语法来触发`save()`方法:\n\n\t<input type=\"button\" value=\"保存\" @keyup.113=\"save\" /> // f2对应的keycode值为113,不能直接使用f2,因为vue事先并未提供\n\n为了更好的见名知意，我们可以通过全局 `config.keyCodes` 对象自定义按键修饰符别名，例如自定义f2的按键修饰符\n\n\tVue.config.keyCodes.f2 = 113 // 当全局自定义完按键修饰符别名f2后，可直接使用f2来达到按键作用\n\t\n\t<input type=\"button\" value=\"保存\" @keyup.f2=\"save\" /> \n","source":"_posts/2018-02-12-vue学习笔记之自定义按键修饰符.md","raw":"---\ntitle: 自定义按键修饰符\ndate: 2018-02-12 19:13:13\ntags: vue\n---\n#### 自定义按键修饰符\n[语法](https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6)： \n> Vue.config.keyCodes.xxx = xxx对应的keyCode值\n\n<!--more-->\n\n我们知道，vue为我们提供了部分“见名知意”的[按键修饰符](https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6)，使用方法如下：\n\n\t<input type=\"button\" value=\"保存\" @keyup.enter=\"save\"/> // 点击enter触发 save() 方法\n\t<input type=\"button\" value=\"保存\" @keyup.13=\"save\"/> // 点击enter触发 save() 方法\n\n除此之外，我们想要使用vue尚未提供的按键修饰符，只能使用按键对应的keyCode值，不能很好的见名知意，例如，我们想按f2键来执行一个`save()`方法，只能查询f2对应的[keyCode](http://www.cnblogs.com/wuhua1/p/6686237.html)值，使用如下语法来触发`save()`方法:\n\n\t<input type=\"button\" value=\"保存\" @keyup.113=\"save\" /> // f2对应的keycode值为113,不能直接使用f2,因为vue事先并未提供\n\n为了更好的见名知意，我们可以通过全局 `config.keyCodes` 对象自定义按键修饰符别名，例如自定义f2的按键修饰符\n\n\tVue.config.keyCodes.f2 = 113 // 当全局自定义完按键修饰符别名f2后，可直接使用f2来达到按键作用\n\t\n\t<input type=\"button\" value=\"保存\" @keyup.f2=\"save\" /> \n","slug":"2018-02-12-vue学习笔记之自定义按键修饰符","published":1,"updated":"2019-03-20T14:33:37.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7gug0004gp9aql790zfe","content":"<h4 id=\"自定义按键修饰符\"><a href=\"#自定义按键修饰符\" class=\"headerlink\" title=\"自定义按键修饰符\"></a>自定义按键修饰符</h4><p><a href=\"https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">语法</a>： </p>\n<blockquote>\n<p>Vue.config.keyCodes.xxx = xxx对应的keyCode值</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>我们知道，vue为我们提供了部分“见名知意”的<a href=\"https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">按键修饰符</a>，使用方法如下：</p>\n<pre><code>&lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.enter=&quot;save&quot;/&gt; // 点击enter触发 save() 方法\n&lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.13=&quot;save&quot;/&gt; // 点击enter触发 save() 方法\n</code></pre><p>除此之外，我们想要使用vue尚未提供的按键修饰符，只能使用按键对应的keyCode值，不能很好的见名知意，例如，我们想按f2键来执行一个<code>save()</code>方法，只能查询f2对应的<a href=\"http://www.cnblogs.com/wuhua1/p/6686237.html\" target=\"_blank\" rel=\"noopener\">keyCode</a>值，使用如下语法来触发<code>save()</code>方法:</p>\n<pre><code>&lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.113=&quot;save&quot; /&gt; // f2对应的keycode值为113,不能直接使用f2,因为vue事先并未提供\n</code></pre><p>为了更好的见名知意，我们可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名，例如自定义f2的按键修饰符</p>\n<pre><code>Vue.config.keyCodes.f2 = 113 // 当全局自定义完按键修饰符别名f2后，可直接使用f2来达到按键作用\n\n&lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.f2=&quot;save&quot; /&gt; \n</code></pre>","site":{"data":{}},"excerpt":"<h4 id=\"自定义按键修饰符\"><a href=\"#自定义按键修饰符\" class=\"headerlink\" title=\"自定义按键修饰符\"></a>自定义按键修饰符</h4><p><a href=\"https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">语法</a>： </p>\n<blockquote>\n<p>Vue.config.keyCodes.xxx = xxx对应的keyCode值</p>\n</blockquote>","more":"<p>我们知道，vue为我们提供了部分“见名知意”的<a href=\"https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">按键修饰符</a>，使用方法如下：</p>\n<pre><code>&lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.enter=&quot;save&quot;/&gt; // 点击enter触发 save() 方法\n&lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.13=&quot;save&quot;/&gt; // 点击enter触发 save() 方法\n</code></pre><p>除此之外，我们想要使用vue尚未提供的按键修饰符，只能使用按键对应的keyCode值，不能很好的见名知意，例如，我们想按f2键来执行一个<code>save()</code>方法，只能查询f2对应的<a href=\"http://www.cnblogs.com/wuhua1/p/6686237.html\" target=\"_blank\" rel=\"noopener\">keyCode</a>值，使用如下语法来触发<code>save()</code>方法:</p>\n<pre><code>&lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.113=&quot;save&quot; /&gt; // f2对应的keycode值为113,不能直接使用f2,因为vue事先并未提供\n</code></pre><p>为了更好的见名知意，我们可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名，例如自定义f2的按键修饰符</p>\n<pre><code>Vue.config.keyCodes.f2 = 113 // 当全局自定义完按键修饰符别名f2后，可直接使用f2来达到按键作用\n\n&lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.f2=&quot;save&quot; /&gt; \n</code></pre>"},{"title":"自定义全局/私有指令","date":"2018-02-12T11:13:13.000Z","_content":"#### 自定义全局/私有指令\n[语法](https://cn.vuejs.org/v2/guide/custom-directive.html)：\n> 全局指令： Vue.directive('xxx', {})\n> \n> 私有指令： directives: {'xxx', {}}\n\n<!--more-->\n1. 在 main.js 中使用  `Vue.directive('xxx', {})` 定义全局指令，此方法接受两个参数\n\t- 参数1： 指令的名称； \n\t\t- **注意：**在定义的时候，指令的名称前面，不需要加 `v-` 前缀，但在调用的时候，必须在指令名称前加上 `v-` 前缀来进行使用\n\t- 参数2： 一个对象，这个对象上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作，对应的函数如下（自定义获取焦点的指令）：\n\n\t\t\tVue.directive('focus', {\n\t\t\t\tbind: el => {\t\n\t\t\t\t\t// 每当指令绑定到元素上时，会立即触发这个bind函数，只执行一次\n\t\t\t\t\t// 在元素刚绑定了指令的时候，还没有插入到DOM中去，这时候，调用操作DOM的方法，并不生效，故在此调用 el.focus()，并不生效\n\t\t\t\t\t// 因为一个元素只有在插入DOM之后，才能获取焦点\n\t\t\t\t\tel.focus() // 不生效\n\t\t\t\t},\n\t\t\t\tinserted: el => {\n\t\t\t\t\t// 该方法表示元素插入到DOM中的时候，会执行inserted函数，同样只执行一次\n\t\t\t\t\tel.focus() // 此处调用操作DOM的方法生效，因为元素已经插入到DOM树中\n\t\t\t\t},\n\t\t\t\tupdated: el => {\n\t\t\t\t\t// 当VNode更新时，会触发updated方法，该方法会触发多次\n\t\t\t\t}\n\t\t\t})\n\n\t\t> 注意：\n\t\t> \n\t\t> - 在每个函数中，第一个参数，永远是 `el` ,表示被绑定了指令的那个元素，这个 `el` 参数，是一个原生的js对象，可调用原生的js方法\n\t\t> - 和样式相关的操作，在bind中写，和行为相关的，在inserted中写，因为诸如el.style.color = \"red\"设置的内联样式来说，最终都要插入到页面中去\n\n\t\t当自定义好全局指令后，可直接在标签内使用 `v-xxx` 绑定指令\n\t\t\n\t\t\t<input type=\"text\" v-foucs />\n\n2. 如果想注册局部指令，组件中接受一个 `directives` （带s）的选项\n\t\t\n\t\tdirectives: {\n\t\t\tfocus: {\n\t\t\t\tbind: el => {\n\t\t\t\t\n\t\t\t\t},\n\t\t\t\tinserted: el => {\n\n\t\t\t\t},\n\t\t\t\tupdated: el => {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 然后可以在模板中任何元素上使用新的 v-focus 属性，如下：\n\t\t<input type=\"text\" v-focus />\n\n3. [点此查看钩子函数对应的其它参数](https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0)\n\n\t\t// 如有需求：动态的修改输入框字体的颜色，可自定义 color 指令\n\t\tVue.directive('color', {\n\t\t\tbind: (el, binding) => {\n\t\t\t\tel.style.color = binding.value\n\t\t\t}\n\t\t})\n\n\t\t// 指定按如下方式绑定，注意参数需带引号，否则为变量，会去data中查值\n\t\t<input type=\"text\" v-color=\"'red'\" /> // 输入框为红色字体\n\t\t<input type=\"text\" v-color=\"'blue'\" /> // 输入框为蓝色字体\n\t\t\n\t> 注意：指令的绑定，遵从就近原则，意：当某一指令，在全局和局部都有自定义时，优先绑定局部指令\n\n4. 自定义指令函数的简写\n\t\n[语法](https://cn.vuejs.org/v2/guide/custom-directive.html#%E5%87%BD%E6%95%B0%E7%AE%80%E5%86%99):\n> 在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:\n> \n> Vue.directive('xxx', function (el, binding) {})\n\n\t// 自定义修改字体大小的指令\n\t// 全局指令\n\tVue.directive('fontsize', (el, binding) => {\n\t\tel.style.fontSize = parseInt(binding.value) + 'px'\n\t})\n\t// 私有指令\n\tdirectives: {\n\t\tfontsize: (el, binding) => {\n\t\t\tel.style.fontSize = parseInt(binding.value) + 'px'\n\t\t}\n\t}\n\n\t// 使用\n\t<input type=\"text\" v-fontsize=\"50\" />\n\t<input type=\"text\" v-fontsize=\"'50px'\" />","source":"_posts/2018-02-12-vue学习笔记之自定义全局和私有指令.md","raw":"---\ntitle: 自定义全局/私有指令\ndate: 2018-02-12 19:13:13\ntags: vue\n---\n#### 自定义全局/私有指令\n[语法](https://cn.vuejs.org/v2/guide/custom-directive.html)：\n> 全局指令： Vue.directive('xxx', {})\n> \n> 私有指令： directives: {'xxx', {}}\n\n<!--more-->\n1. 在 main.js 中使用  `Vue.directive('xxx', {})` 定义全局指令，此方法接受两个参数\n\t- 参数1： 指令的名称； \n\t\t- **注意：**在定义的时候，指令的名称前面，不需要加 `v-` 前缀，但在调用的时候，必须在指令名称前加上 `v-` 前缀来进行使用\n\t- 参数2： 一个对象，这个对象上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作，对应的函数如下（自定义获取焦点的指令）：\n\n\t\t\tVue.directive('focus', {\n\t\t\t\tbind: el => {\t\n\t\t\t\t\t// 每当指令绑定到元素上时，会立即触发这个bind函数，只执行一次\n\t\t\t\t\t// 在元素刚绑定了指令的时候，还没有插入到DOM中去，这时候，调用操作DOM的方法，并不生效，故在此调用 el.focus()，并不生效\n\t\t\t\t\t// 因为一个元素只有在插入DOM之后，才能获取焦点\n\t\t\t\t\tel.focus() // 不生效\n\t\t\t\t},\n\t\t\t\tinserted: el => {\n\t\t\t\t\t// 该方法表示元素插入到DOM中的时候，会执行inserted函数，同样只执行一次\n\t\t\t\t\tel.focus() // 此处调用操作DOM的方法生效，因为元素已经插入到DOM树中\n\t\t\t\t},\n\t\t\t\tupdated: el => {\n\t\t\t\t\t// 当VNode更新时，会触发updated方法，该方法会触发多次\n\t\t\t\t}\n\t\t\t})\n\n\t\t> 注意：\n\t\t> \n\t\t> - 在每个函数中，第一个参数，永远是 `el` ,表示被绑定了指令的那个元素，这个 `el` 参数，是一个原生的js对象，可调用原生的js方法\n\t\t> - 和样式相关的操作，在bind中写，和行为相关的，在inserted中写，因为诸如el.style.color = \"red\"设置的内联样式来说，最终都要插入到页面中去\n\n\t\t当自定义好全局指令后，可直接在标签内使用 `v-xxx` 绑定指令\n\t\t\n\t\t\t<input type=\"text\" v-foucs />\n\n2. 如果想注册局部指令，组件中接受一个 `directives` （带s）的选项\n\t\t\n\t\tdirectives: {\n\t\t\tfocus: {\n\t\t\t\tbind: el => {\n\t\t\t\t\n\t\t\t\t},\n\t\t\t\tinserted: el => {\n\n\t\t\t\t},\n\t\t\t\tupdated: el => {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 然后可以在模板中任何元素上使用新的 v-focus 属性，如下：\n\t\t<input type=\"text\" v-focus />\n\n3. [点此查看钩子函数对应的其它参数](https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0)\n\n\t\t// 如有需求：动态的修改输入框字体的颜色，可自定义 color 指令\n\t\tVue.directive('color', {\n\t\t\tbind: (el, binding) => {\n\t\t\t\tel.style.color = binding.value\n\t\t\t}\n\t\t})\n\n\t\t// 指定按如下方式绑定，注意参数需带引号，否则为变量，会去data中查值\n\t\t<input type=\"text\" v-color=\"'red'\" /> // 输入框为红色字体\n\t\t<input type=\"text\" v-color=\"'blue'\" /> // 输入框为蓝色字体\n\t\t\n\t> 注意：指令的绑定，遵从就近原则，意：当某一指令，在全局和局部都有自定义时，优先绑定局部指令\n\n4. 自定义指令函数的简写\n\t\n[语法](https://cn.vuejs.org/v2/guide/custom-directive.html#%E5%87%BD%E6%95%B0%E7%AE%80%E5%86%99):\n> 在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:\n> \n> Vue.directive('xxx', function (el, binding) {})\n\n\t// 自定义修改字体大小的指令\n\t// 全局指令\n\tVue.directive('fontsize', (el, binding) => {\n\t\tel.style.fontSize = parseInt(binding.value) + 'px'\n\t})\n\t// 私有指令\n\tdirectives: {\n\t\tfontsize: (el, binding) => {\n\t\t\tel.style.fontSize = parseInt(binding.value) + 'px'\n\t\t}\n\t}\n\n\t// 使用\n\t<input type=\"text\" v-fontsize=\"50\" />\n\t<input type=\"text\" v-fontsize=\"'50px'\" />","slug":"2018-02-12-vue学习笔记之自定义全局和私有指令","published":1,"updated":"2019-03-20T14:33:03.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7guh0005gp9alno8s2j9","content":"<h4 id=\"自定义全局-私有指令\"><a href=\"#自定义全局-私有指令\" class=\"headerlink\" title=\"自定义全局/私有指令\"></a>自定义全局/私有指令</h4><p><a href=\"https://cn.vuejs.org/v2/guide/custom-directive.html\" target=\"_blank\" rel=\"noopener\">语法</a>：</p>\n<blockquote>\n<p>全局指令： Vue.directive(‘xxx’, {})</p>\n<p>私有指令： directives: {‘xxx’, {}}</p>\n</blockquote>\n<a id=\"more\"></a>\n<ol>\n<li><p>在 main.js 中使用  <code>Vue.directive(&#39;xxx&#39;, {})</code> 定义全局指令，此方法接受两个参数</p>\n<ul>\n<li>参数1： 指令的名称； <ul>\n<li><strong>注意：</strong>在定义的时候，指令的名称前面，不需要加 <code>v-</code> 前缀，但在调用的时候，必须在指令名称前加上 <code>v-</code> 前缀来进行使用</li>\n</ul>\n</li>\n<li><p>参数2： 一个对象，这个对象上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作，对应的函数如下（自定义获取焦点的指令）：</p>\n<pre><code>Vue.directive(&apos;focus&apos;, {\n    bind: el =&gt; {    \n        // 每当指令绑定到元素上时，会立即触发这个bind函数，只执行一次\n        // 在元素刚绑定了指令的时候，还没有插入到DOM中去，这时候，调用操作DOM的方法，并不生效，故在此调用 el.focus()，并不生效\n        // 因为一个元素只有在插入DOM之后，才能获取焦点\n        el.focus() // 不生效\n    },\n    inserted: el =&gt; {\n        // 该方法表示元素插入到DOM中的时候，会执行inserted函数，同样只执行一次\n        el.focus() // 此处调用操作DOM的方法生效，因为元素已经插入到DOM树中\n    },\n    updated: el =&gt; {\n        // 当VNode更新时，会触发updated方法，该方法会触发多次\n    }\n})\n</code></pre><blockquote>\n<p>注意：</p>\n<ul>\n<li>在每个函数中，第一个参数，永远是 <code>el</code> ,表示被绑定了指令的那个元素，这个 <code>el</code> 参数，是一个原生的js对象，可调用原生的js方法</li>\n<li>和样式相关的操作，在bind中写，和行为相关的，在inserted中写，因为诸如el.style.color = “red”设置的内联样式来说，最终都要插入到页面中去</li>\n</ul>\n</blockquote>\n<p>  当自定义好全局指令后，可直接在标签内使用 <code>v-xxx</code> 绑定指令</p>\n<pre><code>&lt;input type=&quot;text&quot; v-foucs /&gt;\n</code></pre></li>\n</ul>\n</li>\n<li><p>如果想注册局部指令，组件中接受一个 <code>directives</code> （带s）的选项</p>\n<pre><code>directives: {\n    focus: {\n        bind: el =&gt; {\n\n        },\n        inserted: el =&gt; {\n\n        },\n        updated: el =&gt; {\n\n        }\n    }\n}\n\n// 然后可以在模板中任何元素上使用新的 v-focus 属性，如下：\n&lt;input type=&quot;text&quot; v-focus /&gt;\n</code></pre></li>\n<li><p><a href=\"https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\" target=\"_blank\" rel=\"noopener\">点此查看钩子函数对应的其它参数</a></p>\n<pre><code>// 如有需求：动态的修改输入框字体的颜色，可自定义 color 指令\nVue.directive(&apos;color&apos;, {\n    bind: (el, binding) =&gt; {\n        el.style.color = binding.value\n    }\n})\n\n// 指定按如下方式绑定，注意参数需带引号，否则为变量，会去data中查值\n&lt;input type=&quot;text&quot; v-color=&quot;&apos;red&apos;&quot; /&gt; // 输入框为红色字体\n&lt;input type=&quot;text&quot; v-color=&quot;&apos;blue&apos;&quot; /&gt; // 输入框为蓝色字体\n</code></pre><blockquote>\n<p>注意：指令的绑定，遵从就近原则，意：当某一指令，在全局和局部都有自定义时，优先绑定局部指令</p>\n</blockquote>\n</li>\n<li><p>自定义指令函数的简写</p>\n</li>\n</ol>\n<p><a href=\"https://cn.vuejs.org/v2/guide/custom-directive.html#%E5%87%BD%E6%95%B0%E7%AE%80%E5%86%99\" target=\"_blank\" rel=\"noopener\">语法</a>:</p>\n<blockquote>\n<p>在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:</p>\n<p>Vue.directive(‘xxx’, function (el, binding) {})</p>\n</blockquote>\n<pre><code>// 自定义修改字体大小的指令\n// 全局指令\nVue.directive(&apos;fontsize&apos;, (el, binding) =&gt; {\n    el.style.fontSize = parseInt(binding.value) + &apos;px&apos;\n})\n// 私有指令\ndirectives: {\n    fontsize: (el, binding) =&gt; {\n        el.style.fontSize = parseInt(binding.value) + &apos;px&apos;\n    }\n}\n\n// 使用\n&lt;input type=&quot;text&quot; v-fontsize=&quot;50&quot; /&gt;\n&lt;input type=&quot;text&quot; v-fontsize=&quot;&apos;50px&apos;&quot; /&gt;\n</code></pre>","site":{"data":{}},"excerpt":"<h4 id=\"自定义全局-私有指令\"><a href=\"#自定义全局-私有指令\" class=\"headerlink\" title=\"自定义全局/私有指令\"></a>自定义全局/私有指令</h4><p><a href=\"https://cn.vuejs.org/v2/guide/custom-directive.html\" target=\"_blank\" rel=\"noopener\">语法</a>：</p>\n<blockquote>\n<p>全局指令： Vue.directive(‘xxx’, {})</p>\n<p>私有指令： directives: {‘xxx’, {}}</p>\n</blockquote>","more":"<ol>\n<li><p>在 main.js 中使用  <code>Vue.directive(&#39;xxx&#39;, {})</code> 定义全局指令，此方法接受两个参数</p>\n<ul>\n<li>参数1： 指令的名称； <ul>\n<li><strong>注意：</strong>在定义的时候，指令的名称前面，不需要加 <code>v-</code> 前缀，但在调用的时候，必须在指令名称前加上 <code>v-</code> 前缀来进行使用</li>\n</ul>\n</li>\n<li><p>参数2： 一个对象，这个对象上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作，对应的函数如下（自定义获取焦点的指令）：</p>\n<pre><code>Vue.directive(&apos;focus&apos;, {\n    bind: el =&gt; {    \n        // 每当指令绑定到元素上时，会立即触发这个bind函数，只执行一次\n        // 在元素刚绑定了指令的时候，还没有插入到DOM中去，这时候，调用操作DOM的方法，并不生效，故在此调用 el.focus()，并不生效\n        // 因为一个元素只有在插入DOM之后，才能获取焦点\n        el.focus() // 不生效\n    },\n    inserted: el =&gt; {\n        // 该方法表示元素插入到DOM中的时候，会执行inserted函数，同样只执行一次\n        el.focus() // 此处调用操作DOM的方法生效，因为元素已经插入到DOM树中\n    },\n    updated: el =&gt; {\n        // 当VNode更新时，会触发updated方法，该方法会触发多次\n    }\n})\n</code></pre><blockquote>\n<p>注意：</p>\n<ul>\n<li>在每个函数中，第一个参数，永远是 <code>el</code> ,表示被绑定了指令的那个元素，这个 <code>el</code> 参数，是一个原生的js对象，可调用原生的js方法</li>\n<li>和样式相关的操作，在bind中写，和行为相关的，在inserted中写，因为诸如el.style.color = “red”设置的内联样式来说，最终都要插入到页面中去</li>\n</ul>\n</blockquote>\n<p>  当自定义好全局指令后，可直接在标签内使用 <code>v-xxx</code> 绑定指令</p>\n<pre><code>&lt;input type=&quot;text&quot; v-foucs /&gt;\n</code></pre></li>\n</ul>\n</li>\n<li><p>如果想注册局部指令，组件中接受一个 <code>directives</code> （带s）的选项</p>\n<pre><code>directives: {\n    focus: {\n        bind: el =&gt; {\n\n        },\n        inserted: el =&gt; {\n\n        },\n        updated: el =&gt; {\n\n        }\n    }\n}\n\n// 然后可以在模板中任何元素上使用新的 v-focus 属性，如下：\n&lt;input type=&quot;text&quot; v-focus /&gt;\n</code></pre></li>\n<li><p><a href=\"https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\" target=\"_blank\" rel=\"noopener\">点此查看钩子函数对应的其它参数</a></p>\n<pre><code>// 如有需求：动态的修改输入框字体的颜色，可自定义 color 指令\nVue.directive(&apos;color&apos;, {\n    bind: (el, binding) =&gt; {\n        el.style.color = binding.value\n    }\n})\n\n// 指定按如下方式绑定，注意参数需带引号，否则为变量，会去data中查值\n&lt;input type=&quot;text&quot; v-color=&quot;&apos;red&apos;&quot; /&gt; // 输入框为红色字体\n&lt;input type=&quot;text&quot; v-color=&quot;&apos;blue&apos;&quot; /&gt; // 输入框为蓝色字体\n</code></pre><blockquote>\n<p>注意：指令的绑定，遵从就近原则，意：当某一指令，在全局和局部都有自定义时，优先绑定局部指令</p>\n</blockquote>\n</li>\n<li><p>自定义指令函数的简写</p>\n</li>\n</ol>\n<p><a href=\"https://cn.vuejs.org/v2/guide/custom-directive.html#%E5%87%BD%E6%95%B0%E7%AE%80%E5%86%99\" target=\"_blank\" rel=\"noopener\">语法</a>:</p>\n<blockquote>\n<p>在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:</p>\n<p>Vue.directive(‘xxx’, function (el, binding) {})</p>\n</blockquote>\n<pre><code>// 自定义修改字体大小的指令\n// 全局指令\nVue.directive(&apos;fontsize&apos;, (el, binding) =&gt; {\n    el.style.fontSize = parseInt(binding.value) + &apos;px&apos;\n})\n// 私有指令\ndirectives: {\n    fontsize: (el, binding) =&gt; {\n        el.style.fontSize = parseInt(binding.value) + &apos;px&apos;\n    }\n}\n\n// 使用\n&lt;input type=&quot;text&quot; v-fontsize=&quot;50&quot; /&gt;\n&lt;input type=&quot;text&quot; v-fontsize=&quot;&apos;50px&apos;&quot; /&gt;\n</code></pre>"},{"title":"vue过渡类名实现动画","date":"2018-02-12T11:13:13.000Z","_content":"#### vue过渡类名实现动画\n[进入/离开 & 列表过渡](https://cn.vuejs.org/v2/guide/transitions.html)\n\n<!--more-->\n","source":"_posts/2018-02-12-vue学习笔记之过渡类名实现动画.md","raw":"---\ntitle: vue过渡类名实现动画\ndate: 2018-02-12 19:13:13\ntags: vue\n---\n#### vue过渡类名实现动画\n[进入/离开 & 列表过渡](https://cn.vuejs.org/v2/guide/transitions.html)\n\n<!--more-->\n","slug":"2018-02-12-vue学习笔记之过渡类名实现动画","published":1,"updated":"2019-03-20T14:34:41.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7guj0008gp9as7ozbcj3","content":"<h4 id=\"vue过渡类名实现动画\"><a href=\"#vue过渡类名实现动画\" class=\"headerlink\" title=\"vue过渡类名实现动画\"></a>vue过渡类名实现动画</h4><p><a href=\"https://cn.vuejs.org/v2/guide/transitions.html\" target=\"_blank\" rel=\"noopener\">进入/离开 &amp; 列表过渡</a></p>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<h4 id=\"vue过渡类名实现动画\"><a href=\"#vue过渡类名实现动画\" class=\"headerlink\" title=\"vue过渡类名实现动画\"></a>vue过渡类名实现动画</h4><p><a href=\"https://cn.vuejs.org/v2/guide/transitions.html\" target=\"_blank\" rel=\"noopener\">进入/离开 &amp; 列表过渡</a></p>","more":""},{"title":"Mint UI 踩坑之路","date":"2018-02-19T11:13:13.000Z","_content":"#### Mint UI 踩坑之路\n\n##### 1. Mint UI 之 Cell Swipe 用法\n> 官方API如: [Mint UI 之 Cell Swipe](https://mint-ui.github.io/docs/#/en2/cell-swipe)\n\n* Import\n\n\t\timport { CellSwipe } from 'mint-ui'\n\n\t\tVue.component(CellSwipe.name, CellSwipe)\n<!--more-->\n* Example\n\n\t\t<mt-cell-swipe\n\t\t  title=\"text\"\n\t\t  :right=\"[\n\t\t    {\n\t\t      content: 'Delete',\n\t\t      style: { background: 'red', color: '#fff' },\n\t\t      handler: () => this.$messagebox('delete')\n\t\t    }\n\t\t  ]\"></mt-cell-swipe>\n\n> 注意：标签内 handler 中命名的方法，并不能满足我们的需求，可对其进行如下调整，在methods中自定义一个我们所需处理逻辑的方法\n\n\t\n\t<mt-cell-swipe\n\t  title=\"text\"\n\t  v-for=\"(item, index) in lists\"\n\t  :key=\"index\"\n\t  :right=\"[\n\t    {\n\t      content: 'Delete',\n\t      style: { background: 'red', color: '#fff' },\n\t      handler(){deleteItem(index)} // 1.如此修改此handler方法，会调用我们methods中自定义的方法，注：函数名不能命名为delete,严格模式下回报错\n\t    }\n\t  ]\"></mt-cell-swipe>\n\n\tmethods: {\n\t  deleteItem (index) {\n\t    // 2.封装自己处理删除单条数据的方法,index为对应item的索引值\n\n\t\tconsole.log(`删除的为数组中的第${index}项`)\n\t  }\n\t}\n\n> 注意：handler(){ } 中的方法调用，不需要加 this\n\t  \n\n##### 2. Mint UI 之 Message box 用法\n> 官方API如：[Mint UI 之 Message box](https://mint-ui.github.io/docs/#/en2/message-box)\n\n* Import\n\n\t\timport { MessageBox } from 'mint-ui'\n\t\t\n\t\tVue.prototype.$messagebox = MessageBox\n\t\t\n* Example\n\n\t\tthis.$messagebox.confirm('', {\n\t        message: `是否确认删除${this.applyLists[index].name}模板？`,\n\t        title: '',\n\t        confirmButtonText: '确认',\n\t        cancelButtonText: '取消',\n\t        className: 'myMessage'\n\t      }).then(action => {\n\t        if (action === 'confirm') {\n\t          // 确认逻辑\n\t        }\n\t      }).catch(err => {\n\t        if (err === 'cancel') {\n\t          // 取消关闭\n\t        }\n\t      })\n","source":"_posts/2018-02-19-Mint UI踩坑之路.md","raw":"---\ntitle: Mint UI 踩坑之路\ndate: 2018-02-19 19:13:13\ntags: Mint UI\n---\n#### Mint UI 踩坑之路\n\n##### 1. Mint UI 之 Cell Swipe 用法\n> 官方API如: [Mint UI 之 Cell Swipe](https://mint-ui.github.io/docs/#/en2/cell-swipe)\n\n* Import\n\n\t\timport { CellSwipe } from 'mint-ui'\n\n\t\tVue.component(CellSwipe.name, CellSwipe)\n<!--more-->\n* Example\n\n\t\t<mt-cell-swipe\n\t\t  title=\"text\"\n\t\t  :right=\"[\n\t\t    {\n\t\t      content: 'Delete',\n\t\t      style: { background: 'red', color: '#fff' },\n\t\t      handler: () => this.$messagebox('delete')\n\t\t    }\n\t\t  ]\"></mt-cell-swipe>\n\n> 注意：标签内 handler 中命名的方法，并不能满足我们的需求，可对其进行如下调整，在methods中自定义一个我们所需处理逻辑的方法\n\n\t\n\t<mt-cell-swipe\n\t  title=\"text\"\n\t  v-for=\"(item, index) in lists\"\n\t  :key=\"index\"\n\t  :right=\"[\n\t    {\n\t      content: 'Delete',\n\t      style: { background: 'red', color: '#fff' },\n\t      handler(){deleteItem(index)} // 1.如此修改此handler方法，会调用我们methods中自定义的方法，注：函数名不能命名为delete,严格模式下回报错\n\t    }\n\t  ]\"></mt-cell-swipe>\n\n\tmethods: {\n\t  deleteItem (index) {\n\t    // 2.封装自己处理删除单条数据的方法,index为对应item的索引值\n\n\t\tconsole.log(`删除的为数组中的第${index}项`)\n\t  }\n\t}\n\n> 注意：handler(){ } 中的方法调用，不需要加 this\n\t  \n\n##### 2. Mint UI 之 Message box 用法\n> 官方API如：[Mint UI 之 Message box](https://mint-ui.github.io/docs/#/en2/message-box)\n\n* Import\n\n\t\timport { MessageBox } from 'mint-ui'\n\t\t\n\t\tVue.prototype.$messagebox = MessageBox\n\t\t\n* Example\n\n\t\tthis.$messagebox.confirm('', {\n\t        message: `是否确认删除${this.applyLists[index].name}模板？`,\n\t        title: '',\n\t        confirmButtonText: '确认',\n\t        cancelButtonText: '取消',\n\t        className: 'myMessage'\n\t      }).then(action => {\n\t        if (action === 'confirm') {\n\t          // 确认逻辑\n\t        }\n\t      }).catch(err => {\n\t        if (err === 'cancel') {\n\t          // 取消关闭\n\t        }\n\t      })\n","slug":"2018-02-19-Mint UI踩坑之路","published":1,"updated":"2019-03-20T14:31:47.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7guk0009gp9ar8lff279","content":"<h4 id=\"Mint-UI-踩坑之路\"><a href=\"#Mint-UI-踩坑之路\" class=\"headerlink\" title=\"Mint UI 踩坑之路\"></a>Mint UI 踩坑之路</h4><h5 id=\"1-Mint-UI-之-Cell-Swipe-用法\"><a href=\"#1-Mint-UI-之-Cell-Swipe-用法\" class=\"headerlink\" title=\"1. Mint UI 之 Cell Swipe 用法\"></a>1. Mint UI 之 Cell Swipe 用法</h5><blockquote>\n<p>官方API如: <a href=\"https://mint-ui.github.io/docs/#/en2/cell-swipe\" target=\"_blank\" rel=\"noopener\">Mint UI 之 Cell Swipe</a></p>\n</blockquote>\n<ul>\n<li><p>Import</p>\n<pre><code>import { CellSwipe } from &apos;mint-ui&apos;\n\nVue.component(CellSwipe.name, CellSwipe)\n</code></pre><a id=\"more\"></a></li>\n<li><p>Example</p>\n<pre><code>&lt;mt-cell-swipe\n  title=&quot;text&quot;\n  :right=&quot;[\n    {\n      content: &apos;Delete&apos;,\n      style: { background: &apos;red&apos;, color: &apos;#fff&apos; },\n      handler: () =&gt; this.$messagebox(&apos;delete&apos;)\n    }\n  ]&quot;&gt;&lt;/mt-cell-swipe&gt;\n</code></pre></li>\n</ul>\n<blockquote>\n<p>注意：标签内 handler 中命名的方法，并不能满足我们的需求，可对其进行如下调整，在methods中自定义一个我们所需处理逻辑的方法</p>\n</blockquote>\n<pre><code>&lt;mt-cell-swipe\n  title=&quot;text&quot;\n  v-for=&quot;(item, index) in lists&quot;\n  :key=&quot;index&quot;\n  :right=&quot;[\n    {\n      content: &apos;Delete&apos;,\n      style: { background: &apos;red&apos;, color: &apos;#fff&apos; },\n      handler(){deleteItem(index)} // 1.如此修改此handler方法，会调用我们methods中自定义的方法，注：函数名不能命名为delete,严格模式下回报错\n    }\n  ]&quot;&gt;&lt;/mt-cell-swipe&gt;\n\nmethods: {\n  deleteItem (index) {\n    // 2.封装自己处理删除单条数据的方法,index为对应item的索引值\n\n    console.log(`删除的为数组中的第${index}项`)\n  }\n}\n</code></pre><blockquote>\n<p>注意：handler(){ } 中的方法调用，不需要加 this</p>\n</blockquote>\n<h5 id=\"2-Mint-UI-之-Message-box-用法\"><a href=\"#2-Mint-UI-之-Message-box-用法\" class=\"headerlink\" title=\"2. Mint UI 之 Message box 用法\"></a>2. Mint UI 之 Message box 用法</h5><blockquote>\n<p>官方API如：<a href=\"https://mint-ui.github.io/docs/#/en2/message-box\" target=\"_blank\" rel=\"noopener\">Mint UI 之 Message box</a></p>\n</blockquote>\n<ul>\n<li><p>Import</p>\n<pre><code>import { MessageBox } from &apos;mint-ui&apos;\n\nVue.prototype.$messagebox = MessageBox\n</code></pre></li>\n<li><p>Example</p>\n<pre><code>this.$messagebox.confirm(&apos;&apos;, {\n    message: `是否确认删除${this.applyLists[index].name}模板？`,\n    title: &apos;&apos;,\n    confirmButtonText: &apos;确认&apos;,\n    cancelButtonText: &apos;取消&apos;,\n    className: &apos;myMessage&apos;\n  }).then(action =&gt; {\n    if (action === &apos;confirm&apos;) {\n      // 确认逻辑\n    }\n  }).catch(err =&gt; {\n    if (err === &apos;cancel&apos;) {\n      // 取消关闭\n    }\n  })\n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"Mint-UI-踩坑之路\"><a href=\"#Mint-UI-踩坑之路\" class=\"headerlink\" title=\"Mint UI 踩坑之路\"></a>Mint UI 踩坑之路</h4><h5 id=\"1-Mint-UI-之-Cell-Swipe-用法\"><a href=\"#1-Mint-UI-之-Cell-Swipe-用法\" class=\"headerlink\" title=\"1. Mint UI 之 Cell Swipe 用法\"></a>1. Mint UI 之 Cell Swipe 用法</h5><blockquote>\n<p>官方API如: <a href=\"https://mint-ui.github.io/docs/#/en2/cell-swipe\" target=\"_blank\" rel=\"noopener\">Mint UI 之 Cell Swipe</a></p>\n</blockquote>\n<ul>\n<li><p>Import</p>\n<pre><code>import { CellSwipe } from &apos;mint-ui&apos;\n\nVue.component(CellSwipe.name, CellSwipe)\n</code></pre></li></ul>","more":"</li>\n<li><p>Example</p>\n<pre><code>&lt;mt-cell-swipe\n  title=&quot;text&quot;\n  :right=&quot;[\n    {\n      content: &apos;Delete&apos;,\n      style: { background: &apos;red&apos;, color: &apos;#fff&apos; },\n      handler: () =&gt; this.$messagebox(&apos;delete&apos;)\n    }\n  ]&quot;&gt;&lt;/mt-cell-swipe&gt;\n</code></pre></li>\n</ul>\n<blockquote>\n<p>注意：标签内 handler 中命名的方法，并不能满足我们的需求，可对其进行如下调整，在methods中自定义一个我们所需处理逻辑的方法</p>\n</blockquote>\n<pre><code>&lt;mt-cell-swipe\n  title=&quot;text&quot;\n  v-for=&quot;(item, index) in lists&quot;\n  :key=&quot;index&quot;\n  :right=&quot;[\n    {\n      content: &apos;Delete&apos;,\n      style: { background: &apos;red&apos;, color: &apos;#fff&apos; },\n      handler(){deleteItem(index)} // 1.如此修改此handler方法，会调用我们methods中自定义的方法，注：函数名不能命名为delete,严格模式下回报错\n    }\n  ]&quot;&gt;&lt;/mt-cell-swipe&gt;\n\nmethods: {\n  deleteItem (index) {\n    // 2.封装自己处理删除单条数据的方法,index为对应item的索引值\n\n    console.log(`删除的为数组中的第${index}项`)\n  }\n}\n</code></pre><blockquote>\n<p>注意：handler(){ } 中的方法调用，不需要加 this</p>\n</blockquote>\n<h5 id=\"2-Mint-UI-之-Message-box-用法\"><a href=\"#2-Mint-UI-之-Message-box-用法\" class=\"headerlink\" title=\"2. Mint UI 之 Message box 用法\"></a>2. Mint UI 之 Message box 用法</h5><blockquote>\n<p>官方API如：<a href=\"https://mint-ui.github.io/docs/#/en2/message-box\" target=\"_blank\" rel=\"noopener\">Mint UI 之 Message box</a></p>\n</blockquote>\n<ul>\n<li><p>Import</p>\n<pre><code>import { MessageBox } from &apos;mint-ui&apos;\n\nVue.prototype.$messagebox = MessageBox\n</code></pre></li>\n<li><p>Example</p>\n<pre><code>this.$messagebox.confirm(&apos;&apos;, {\n    message: `是否确认删除${this.applyLists[index].name}模板？`,\n    title: &apos;&apos;,\n    confirmButtonText: &apos;确认&apos;,\n    cancelButtonText: &apos;取消&apos;,\n    className: &apos;myMessage&apos;\n  }).then(action =&gt; {\n    if (action === &apos;confirm&apos;) {\n      // 确认逻辑\n    }\n  }).catch(err =&gt; {\n    if (err === &apos;cancel&apos;) {\n      // 取消关闭\n    }\n  })\n</code></pre></li>\n</ul>"},{"title":"charles连接手机抓包","date":"2018-02-19T11:13:13.000Z","_content":"#### charles连接手机抓包\n> 必须保证电脑和手机在一个局域网下\n\n###### 连接步骤：\n1. 打开charles，依次点击 Proxy - Proxy Settings... - 勾选Enable transparent HTTP proxying - ok。\n\n![勾选 Enable transparent HTTP proxying](https://y-cwei.github.io/styles/images/mdimages/charles_01.png)\n<!--more-->\n2. 电脑终端 cmd ，输入 ipconfig 查看本机 ip 。\n3. 打开手机，连入和电脑相同的局域网关，手动配置http代理，服务器与电脑 ip 保持一致，端口与步骤一Proxy Settings...中的端口号保持一致。\n\n![手动配置代理](https://y-cwei.github.io/styles/images/mdimages/charles_02.png)\n\n4. 此时charles会给出提示。有新的连接。点击allow。\n5. 连接成功，此时手机发送的内容，charles可以抓到。\n\n> 注意： 然后如果勾选了Proxy - Windows Proxy 的话，那么就会将电脑上的抓包请求也抓取到，如果只抓手机的话，建议取消这个勾选设置。\n\n###### 一百种charles连接不上手机的处理方式：\n1. 检查电脑和手机有没有连接的同一个wifi，必须tm连接的一个网\n2. 更换charles和移动端设备的端口，默认是8888，可以改成其他的试试\n3. 有可能路由器设置的ap间不能相互访问，需要登录路由器，需要登录路由器。进行求改。把用户间访问的对勾勾上。类似于这样\n4. 关闭电脑的防火墙。试试 首先，如果，防火墙关了还是不行，那么请把手机wifi断掉后重新连接，这样一般就可以解决问题了。 如果以上方法还是不行的话，那么请将手机wifi位置的ip地址设置成静态ip，然后重启charles工具。\n5. 在charles上添加手机的ip试试\n\n![手动配置代理](https://y-cwei.github.io/styles/images/mdimages/charles_03.jpg)\n","source":"_posts/2018-02-19-charles连接手机抓包.md","raw":"---\ntitle: charles连接手机抓包\ndate: 2018-02-19 19:13:13\ntags: charles\n---\n#### charles连接手机抓包\n> 必须保证电脑和手机在一个局域网下\n\n###### 连接步骤：\n1. 打开charles，依次点击 Proxy - Proxy Settings... - 勾选Enable transparent HTTP proxying - ok。\n\n![勾选 Enable transparent HTTP proxying](https://y-cwei.github.io/styles/images/mdimages/charles_01.png)\n<!--more-->\n2. 电脑终端 cmd ，输入 ipconfig 查看本机 ip 。\n3. 打开手机，连入和电脑相同的局域网关，手动配置http代理，服务器与电脑 ip 保持一致，端口与步骤一Proxy Settings...中的端口号保持一致。\n\n![手动配置代理](https://y-cwei.github.io/styles/images/mdimages/charles_02.png)\n\n4. 此时charles会给出提示。有新的连接。点击allow。\n5. 连接成功，此时手机发送的内容，charles可以抓到。\n\n> 注意： 然后如果勾选了Proxy - Windows Proxy 的话，那么就会将电脑上的抓包请求也抓取到，如果只抓手机的话，建议取消这个勾选设置。\n\n###### 一百种charles连接不上手机的处理方式：\n1. 检查电脑和手机有没有连接的同一个wifi，必须tm连接的一个网\n2. 更换charles和移动端设备的端口，默认是8888，可以改成其他的试试\n3. 有可能路由器设置的ap间不能相互访问，需要登录路由器，需要登录路由器。进行求改。把用户间访问的对勾勾上。类似于这样\n4. 关闭电脑的防火墙。试试 首先，如果，防火墙关了还是不行，那么请把手机wifi断掉后重新连接，这样一般就可以解决问题了。 如果以上方法还是不行的话，那么请将手机wifi位置的ip地址设置成静态ip，然后重启charles工具。\n5. 在charles上添加手机的ip试试\n\n![手动配置代理](https://y-cwei.github.io/styles/images/mdimages/charles_03.jpg)\n","slug":"2018-02-19-charles连接手机抓包","published":1,"updated":"2019-03-20T14:32:00.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7gum000cgp9abvy6aec9","content":"<h4 id=\"charles连接手机抓包\"><a href=\"#charles连接手机抓包\" class=\"headerlink\" title=\"charles连接手机抓包\"></a>charles连接手机抓包</h4><blockquote>\n<p>必须保证电脑和手机在一个局域网下</p>\n</blockquote>\n<h6 id=\"连接步骤：\"><a href=\"#连接步骤：\" class=\"headerlink\" title=\"连接步骤：\"></a>连接步骤：</h6><ol>\n<li>打开charles，依次点击 Proxy - Proxy Settings… - 勾选Enable transparent HTTP proxying - ok。</li>\n</ol>\n<p><img src=\"https://y-cwei.github.io/styles/images/mdimages/charles_01.png\" alt=\"勾选 Enable transparent HTTP proxying\"><br><a id=\"more\"></a></p>\n<ol start=\"2\">\n<li>电脑终端 cmd ，输入 ipconfig 查看本机 ip 。</li>\n<li>打开手机，连入和电脑相同的局域网关，手动配置http代理，服务器与电脑 ip 保持一致，端口与步骤一Proxy Settings…中的端口号保持一致。</li>\n</ol>\n<p><img src=\"https://y-cwei.github.io/styles/images/mdimages/charles_02.png\" alt=\"手动配置代理\"></p>\n<ol start=\"4\">\n<li>此时charles会给出提示。有新的连接。点击allow。</li>\n<li>连接成功，此时手机发送的内容，charles可以抓到。</li>\n</ol>\n<blockquote>\n<p>注意： 然后如果勾选了Proxy - Windows Proxy 的话，那么就会将电脑上的抓包请求也抓取到，如果只抓手机的话，建议取消这个勾选设置。</p>\n</blockquote>\n<h6 id=\"一百种charles连接不上手机的处理方式：\"><a href=\"#一百种charles连接不上手机的处理方式：\" class=\"headerlink\" title=\"一百种charles连接不上手机的处理方式：\"></a>一百种charles连接不上手机的处理方式：</h6><ol>\n<li>检查电脑和手机有没有连接的同一个wifi，必须tm连接的一个网</li>\n<li>更换charles和移动端设备的端口，默认是8888，可以改成其他的试试</li>\n<li>有可能路由器设置的ap间不能相互访问，需要登录路由器，需要登录路由器。进行求改。把用户间访问的对勾勾上。类似于这样</li>\n<li>关闭电脑的防火墙。试试 首先，如果，防火墙关了还是不行，那么请把手机wifi断掉后重新连接，这样一般就可以解决问题了。 如果以上方法还是不行的话，那么请将手机wifi位置的ip地址设置成静态ip，然后重启charles工具。</li>\n<li>在charles上添加手机的ip试试</li>\n</ol>\n<p><img src=\"https://y-cwei.github.io/styles/images/mdimages/charles_03.jpg\" alt=\"手动配置代理\"></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"charles连接手机抓包\"><a href=\"#charles连接手机抓包\" class=\"headerlink\" title=\"charles连接手机抓包\"></a>charles连接手机抓包</h4><blockquote>\n<p>必须保证电脑和手机在一个局域网下</p>\n</blockquote>\n<h6 id=\"连接步骤：\"><a href=\"#连接步骤：\" class=\"headerlink\" title=\"连接步骤：\"></a>连接步骤：</h6><ol>\n<li>打开charles，依次点击 Proxy - Proxy Settings… - 勾选Enable transparent HTTP proxying - ok。</li>\n</ol>\n<p><img src=\"https://y-cwei.github.io/styles/images/mdimages/charles_01.png\" alt=\"勾选 Enable transparent HTTP proxying\"><br></p>","more":"</p>\n<ol start=\"2\">\n<li>电脑终端 cmd ，输入 ipconfig 查看本机 ip 。</li>\n<li>打开手机，连入和电脑相同的局域网关，手动配置http代理，服务器与电脑 ip 保持一致，端口与步骤一Proxy Settings…中的端口号保持一致。</li>\n</ol>\n<p><img src=\"https://y-cwei.github.io/styles/images/mdimages/charles_02.png\" alt=\"手动配置代理\"></p>\n<ol start=\"4\">\n<li>此时charles会给出提示。有新的连接。点击allow。</li>\n<li>连接成功，此时手机发送的内容，charles可以抓到。</li>\n</ol>\n<blockquote>\n<p>注意： 然后如果勾选了Proxy - Windows Proxy 的话，那么就会将电脑上的抓包请求也抓取到，如果只抓手机的话，建议取消这个勾选设置。</p>\n</blockquote>\n<h6 id=\"一百种charles连接不上手机的处理方式：\"><a href=\"#一百种charles连接不上手机的处理方式：\" class=\"headerlink\" title=\"一百种charles连接不上手机的处理方式：\"></a>一百种charles连接不上手机的处理方式：</h6><ol>\n<li>检查电脑和手机有没有连接的同一个wifi，必须tm连接的一个网</li>\n<li>更换charles和移动端设备的端口，默认是8888，可以改成其他的试试</li>\n<li>有可能路由器设置的ap间不能相互访问，需要登录路由器，需要登录路由器。进行求改。把用户间访问的对勾勾上。类似于这样</li>\n<li>关闭电脑的防火墙。试试 首先，如果，防火墙关了还是不行，那么请把手机wifi断掉后重新连接，这样一般就可以解决问题了。 如果以上方法还是不行的话，那么请将手机wifi位置的ip地址设置成静态ip，然后重启charles工具。</li>\n<li>在charles上添加手机的ip试试</li>\n</ol>\n<p><img src=\"https://y-cwei.github.io/styles/images/mdimages/charles_03.jpg\" alt=\"手动配置代理\"></p>"},{"title":"常用js代码片段","date":"2018-02-19T11:13:13.000Z","_content":"#### 常用js代码片段\n\n##### 1.获取当前时间（年-月-日 时:分）\n\n\tmodule.exports = {\n\t\tgetNowTime (connector) { // connector 连接符，不传默认为 -\n\t\t    if (!connector) connector = '-'\n\t\t    const nowTime = new Date()\n\t\t    const nowMonth = nowTime.getMonth()+1 < 10 ? '0' + (nowTime.getMonth()+1) : nowTime.getMonth() + 1\n\t\t    const nowDay = nowTime.getDay() < 10 ? '0' + nowTime.getDay() : nowTime.getDay()\n\t\t    const nowHours = nowTime.getHours() < 10 ? '0' + nowTime.getHours() : nowTime.getHours()\n\t\t    const nowMinute = nowTime.getMinutes() < 10 ? '0' + nowTime.getMinutes() : nowTime.getMinutes()\n\t\t    return nowTime.getFullYear() + connector + nowMonth + connector + nowDay + ' ' + nowHours + ':' + nowMinute\n\t\t  }\n\t}\n\n\t// 获取结果为： 2018-02-12 17:08\n<!--more-->\n##### 2.向左滑动展示删除按钮功能\n\t\n\t//向左滑动展示删除会议按钮\n    function showDeleteWithSlide () {\n    \tvar slideItem = $('.meetingList').find('ul');\n    \tvar slideStartX=0, slideStartY=0, slideEndX=0, slideEndY=0, slideX=0, slideY=0;\n    \tslideItem.on('touchstart', function (e) {\n    \t\te.stopPropagation();\n    \t\tslideStartX = e.changedTouches[0].clientX;\n    \t\tslideStartY = e.changedTouches[0].clientY;\n    \t});\n    \tslideItem.on('touchmove', function(e){\n    \t\te.stopPropagation();\n    \t\tslideEndX = e.changedTouches[0].clientX;\n    \t\tslideEndY = e.changedTouches[0].clientY;\n    \t\tslideX = slideEndX - slideStartX;\n    \t\tslideY = slideEndY - slideStartY;\n    \t\tif(Math.abs(slideY) >= Math.abs(slideX)) { //竖向滑动\n    \t\t\tslideItem.each(function(){\n    \t\t\t\tif($(this).hasClass('show-from-right')){\n    \t\t\t\t\t$(this).removeClass('show-from-right').addClass('hide-to-right');\n    \t\t\t\t\tif('meeting_type' == $(this).children('li:last-child').attr('class') && $(this).children('li:last-child').text()) $(this).children('li:last-child').show();\n    \t\t\t\t}\n    \t\t\t})\n    \t\t\treturn; //竖向滑动释放默认行为\n    \t\t};\n    \t\te.preventDefault();\n    \t});\n    \tslideItem.on('touchend', function(e){\n    \t\te.stopPropagation();\n    \t\tif(slideX<-50){\n    \t\t\t$(this).removeClass('hide-to-right').addClass('show-from-right');\n    \t\t}else if (slideX>50) {\n    \t\t\tif($(this).hasClass('show-from-right')) $(this).removeClass('show-from-right').addClass('hide-to-right');\n    \t\t}\n    \t\t\n    \t\tif(Math.abs(slideX)>50 && 'meeting_type' == $(this).children('li:last-child').attr('class') && 'show-from-right' == $(this).attr('class')) {\n    \t\t\t$(this).children('li:last-child').hide();\n    \t\t}else if(Math.abs(slideX)>50 && 'meeting_type' == $(this).children('li:last-child').attr('class') && 'hide-to-right' == $(this).attr('class') && $(this).children('li:last-child').text()){\n    \t\t\t$(this).children('li:last-child').show();\n    \t\t};\n    \t})\n    }","source":"_posts/2018-02-19-常用代码片段.md","raw":"---\ntitle: 常用js代码片段\ndate: 2018-02-19 19:13:13\ntags: js\n---\n#### 常用js代码片段\n\n##### 1.获取当前时间（年-月-日 时:分）\n\n\tmodule.exports = {\n\t\tgetNowTime (connector) { // connector 连接符，不传默认为 -\n\t\t    if (!connector) connector = '-'\n\t\t    const nowTime = new Date()\n\t\t    const nowMonth = nowTime.getMonth()+1 < 10 ? '0' + (nowTime.getMonth()+1) : nowTime.getMonth() + 1\n\t\t    const nowDay = nowTime.getDay() < 10 ? '0' + nowTime.getDay() : nowTime.getDay()\n\t\t    const nowHours = nowTime.getHours() < 10 ? '0' + nowTime.getHours() : nowTime.getHours()\n\t\t    const nowMinute = nowTime.getMinutes() < 10 ? '0' + nowTime.getMinutes() : nowTime.getMinutes()\n\t\t    return nowTime.getFullYear() + connector + nowMonth + connector + nowDay + ' ' + nowHours + ':' + nowMinute\n\t\t  }\n\t}\n\n\t// 获取结果为： 2018-02-12 17:08\n<!--more-->\n##### 2.向左滑动展示删除按钮功能\n\t\n\t//向左滑动展示删除会议按钮\n    function showDeleteWithSlide () {\n    \tvar slideItem = $('.meetingList').find('ul');\n    \tvar slideStartX=0, slideStartY=0, slideEndX=0, slideEndY=0, slideX=0, slideY=0;\n    \tslideItem.on('touchstart', function (e) {\n    \t\te.stopPropagation();\n    \t\tslideStartX = e.changedTouches[0].clientX;\n    \t\tslideStartY = e.changedTouches[0].clientY;\n    \t});\n    \tslideItem.on('touchmove', function(e){\n    \t\te.stopPropagation();\n    \t\tslideEndX = e.changedTouches[0].clientX;\n    \t\tslideEndY = e.changedTouches[0].clientY;\n    \t\tslideX = slideEndX - slideStartX;\n    \t\tslideY = slideEndY - slideStartY;\n    \t\tif(Math.abs(slideY) >= Math.abs(slideX)) { //竖向滑动\n    \t\t\tslideItem.each(function(){\n    \t\t\t\tif($(this).hasClass('show-from-right')){\n    \t\t\t\t\t$(this).removeClass('show-from-right').addClass('hide-to-right');\n    \t\t\t\t\tif('meeting_type' == $(this).children('li:last-child').attr('class') && $(this).children('li:last-child').text()) $(this).children('li:last-child').show();\n    \t\t\t\t}\n    \t\t\t})\n    \t\t\treturn; //竖向滑动释放默认行为\n    \t\t};\n    \t\te.preventDefault();\n    \t});\n    \tslideItem.on('touchend', function(e){\n    \t\te.stopPropagation();\n    \t\tif(slideX<-50){\n    \t\t\t$(this).removeClass('hide-to-right').addClass('show-from-right');\n    \t\t}else if (slideX>50) {\n    \t\t\tif($(this).hasClass('show-from-right')) $(this).removeClass('show-from-right').addClass('hide-to-right');\n    \t\t}\n    \t\t\n    \t\tif(Math.abs(slideX)>50 && 'meeting_type' == $(this).children('li:last-child').attr('class') && 'show-from-right' == $(this).attr('class')) {\n    \t\t\t$(this).children('li:last-child').hide();\n    \t\t}else if(Math.abs(slideX)>50 && 'meeting_type' == $(this).children('li:last-child').attr('class') && 'hide-to-right' == $(this).attr('class') && $(this).children('li:last-child').text()){\n    \t\t\t$(this).children('li:last-child').show();\n    \t\t};\n    \t})\n    }","slug":"2018-02-19-常用代码片段","published":1,"updated":"2019-03-20T14:32:53.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7gun000egp9az5ebo72w","content":"<h4 id=\"常用js代码片段\"><a href=\"#常用js代码片段\" class=\"headerlink\" title=\"常用js代码片段\"></a>常用js代码片段</h4><h5 id=\"1-获取当前时间（年-月-日-时-分）\"><a href=\"#1-获取当前时间（年-月-日-时-分）\" class=\"headerlink\" title=\"1.获取当前时间（年-月-日 时:分）\"></a>1.获取当前时间（年-月-日 时:分）</h5><pre><code>module.exports = {\n    getNowTime (connector) { // connector 连接符，不传默认为 -\n        if (!connector) connector = &apos;-&apos;\n        const nowTime = new Date()\n        const nowMonth = nowTime.getMonth()+1 &lt; 10 ? &apos;0&apos; + (nowTime.getMonth()+1) : nowTime.getMonth() + 1\n        const nowDay = nowTime.getDay() &lt; 10 ? &apos;0&apos; + nowTime.getDay() : nowTime.getDay()\n        const nowHours = nowTime.getHours() &lt; 10 ? &apos;0&apos; + nowTime.getHours() : nowTime.getHours()\n        const nowMinute = nowTime.getMinutes() &lt; 10 ? &apos;0&apos; + nowTime.getMinutes() : nowTime.getMinutes()\n        return nowTime.getFullYear() + connector + nowMonth + connector + nowDay + &apos; &apos; + nowHours + &apos;:&apos; + nowMinute\n      }\n}\n\n// 获取结果为： 2018-02-12 17:08\n</code></pre><a id=\"more\"></a>\n<h5 id=\"2-向左滑动展示删除按钮功能\"><a href=\"#2-向左滑动展示删除按钮功能\" class=\"headerlink\" title=\"2.向左滑动展示删除按钮功能\"></a>2.向左滑动展示删除按钮功能</h5><pre><code>//向左滑动展示删除会议按钮\nfunction showDeleteWithSlide () {\n    var slideItem = $(&apos;.meetingList&apos;).find(&apos;ul&apos;);\n    var slideStartX=0, slideStartY=0, slideEndX=0, slideEndY=0, slideX=0, slideY=0;\n    slideItem.on(&apos;touchstart&apos;, function (e) {\n        e.stopPropagation();\n        slideStartX = e.changedTouches[0].clientX;\n        slideStartY = e.changedTouches[0].clientY;\n    });\n    slideItem.on(&apos;touchmove&apos;, function(e){\n        e.stopPropagation();\n        slideEndX = e.changedTouches[0].clientX;\n        slideEndY = e.changedTouches[0].clientY;\n        slideX = slideEndX - slideStartX;\n        slideY = slideEndY - slideStartY;\n        if(Math.abs(slideY) &gt;= Math.abs(slideX)) { //竖向滑动\n            slideItem.each(function(){\n                if($(this).hasClass(&apos;show-from-right&apos;)){\n                    $(this).removeClass(&apos;show-from-right&apos;).addClass(&apos;hide-to-right&apos;);\n                    if(&apos;meeting_type&apos; == $(this).children(&apos;li:last-child&apos;).attr(&apos;class&apos;) &amp;&amp; $(this).children(&apos;li:last-child&apos;).text()) $(this).children(&apos;li:last-child&apos;).show();\n                }\n            })\n            return; //竖向滑动释放默认行为\n        };\n        e.preventDefault();\n    });\n    slideItem.on(&apos;touchend&apos;, function(e){\n        e.stopPropagation();\n        if(slideX&lt;-50){\n            $(this).removeClass(&apos;hide-to-right&apos;).addClass(&apos;show-from-right&apos;);\n        }else if (slideX&gt;50) {\n            if($(this).hasClass(&apos;show-from-right&apos;)) $(this).removeClass(&apos;show-from-right&apos;).addClass(&apos;hide-to-right&apos;);\n        }\n\n        if(Math.abs(slideX)&gt;50 &amp;&amp; &apos;meeting_type&apos; == $(this).children(&apos;li:last-child&apos;).attr(&apos;class&apos;) &amp;&amp; &apos;show-from-right&apos; == $(this).attr(&apos;class&apos;)) {\n            $(this).children(&apos;li:last-child&apos;).hide();\n        }else if(Math.abs(slideX)&gt;50 &amp;&amp; &apos;meeting_type&apos; == $(this).children(&apos;li:last-child&apos;).attr(&apos;class&apos;) &amp;&amp; &apos;hide-to-right&apos; == $(this).attr(&apos;class&apos;) &amp;&amp; $(this).children(&apos;li:last-child&apos;).text()){\n            $(this).children(&apos;li:last-child&apos;).show();\n        };\n    })\n}\n</code></pre>","site":{"data":{}},"excerpt":"<h4 id=\"常用js代码片段\"><a href=\"#常用js代码片段\" class=\"headerlink\" title=\"常用js代码片段\"></a>常用js代码片段</h4><h5 id=\"1-获取当前时间（年-月-日-时-分）\"><a href=\"#1-获取当前时间（年-月-日-时-分）\" class=\"headerlink\" title=\"1.获取当前时间（年-月-日 时:分）\"></a>1.获取当前时间（年-月-日 时:分）</h5><pre><code>module.exports = {\n    getNowTime (connector) { // connector 连接符，不传默认为 -\n        if (!connector) connector = &apos;-&apos;\n        const nowTime = new Date()\n        const nowMonth = nowTime.getMonth()+1 &lt; 10 ? &apos;0&apos; + (nowTime.getMonth()+1) : nowTime.getMonth() + 1\n        const nowDay = nowTime.getDay() &lt; 10 ? &apos;0&apos; + nowTime.getDay() : nowTime.getDay()\n        const nowHours = nowTime.getHours() &lt; 10 ? &apos;0&apos; + nowTime.getHours() : nowTime.getHours()\n        const nowMinute = nowTime.getMinutes() &lt; 10 ? &apos;0&apos; + nowTime.getMinutes() : nowTime.getMinutes()\n        return nowTime.getFullYear() + connector + nowMonth + connector + nowDay + &apos; &apos; + nowHours + &apos;:&apos; + nowMinute\n      }\n}\n\n// 获取结果为： 2018-02-12 17:08\n</code></pre>","more":"<h5 id=\"2-向左滑动展示删除按钮功能\"><a href=\"#2-向左滑动展示删除按钮功能\" class=\"headerlink\" title=\"2.向左滑动展示删除按钮功能\"></a>2.向左滑动展示删除按钮功能</h5><pre><code>//向左滑动展示删除会议按钮\nfunction showDeleteWithSlide () {\n    var slideItem = $(&apos;.meetingList&apos;).find(&apos;ul&apos;);\n    var slideStartX=0, slideStartY=0, slideEndX=0, slideEndY=0, slideX=0, slideY=0;\n    slideItem.on(&apos;touchstart&apos;, function (e) {\n        e.stopPropagation();\n        slideStartX = e.changedTouches[0].clientX;\n        slideStartY = e.changedTouches[0].clientY;\n    });\n    slideItem.on(&apos;touchmove&apos;, function(e){\n        e.stopPropagation();\n        slideEndX = e.changedTouches[0].clientX;\n        slideEndY = e.changedTouches[0].clientY;\n        slideX = slideEndX - slideStartX;\n        slideY = slideEndY - slideStartY;\n        if(Math.abs(slideY) &gt;= Math.abs(slideX)) { //竖向滑动\n            slideItem.each(function(){\n                if($(this).hasClass(&apos;show-from-right&apos;)){\n                    $(this).removeClass(&apos;show-from-right&apos;).addClass(&apos;hide-to-right&apos;);\n                    if(&apos;meeting_type&apos; == $(this).children(&apos;li:last-child&apos;).attr(&apos;class&apos;) &amp;&amp; $(this).children(&apos;li:last-child&apos;).text()) $(this).children(&apos;li:last-child&apos;).show();\n                }\n            })\n            return; //竖向滑动释放默认行为\n        };\n        e.preventDefault();\n    });\n    slideItem.on(&apos;touchend&apos;, function(e){\n        e.stopPropagation();\n        if(slideX&lt;-50){\n            $(this).removeClass(&apos;hide-to-right&apos;).addClass(&apos;show-from-right&apos;);\n        }else if (slideX&gt;50) {\n            if($(this).hasClass(&apos;show-from-right&apos;)) $(this).removeClass(&apos;show-from-right&apos;).addClass(&apos;hide-to-right&apos;);\n        }\n\n        if(Math.abs(slideX)&gt;50 &amp;&amp; &apos;meeting_type&apos; == $(this).children(&apos;li:last-child&apos;).attr(&apos;class&apos;) &amp;&amp; &apos;show-from-right&apos; == $(this).attr(&apos;class&apos;)) {\n            $(this).children(&apos;li:last-child&apos;).hide();\n        }else if(Math.abs(slideX)&gt;50 &amp;&amp; &apos;meeting_type&apos; == $(this).children(&apos;li:last-child&apos;).attr(&apos;class&apos;) &amp;&amp; &apos;hide-to-right&apos; == $(this).attr(&apos;class&apos;) &amp;&amp; $(this).children(&apos;li:last-child&apos;).text()){\n            $(this).children(&apos;li:last-child&apos;).show();\n        };\n    })\n}\n</code></pre>"},{"title":"前后端交互之跨域问题","date":"2019-01-11T11:13:13.000Z","_content":"#### 前后端交互之跨域问题\n跨域出现的原因：浏览器为安全性考虑而实施的同源策略\t，当协议名，域名，端口号三者中任一一种不相同，就会产生跨域问题。\n\n##### 1. jsonp解决跨域\n> 在 HTML 标签里，一些诸如 script、img 这样的资源的标签是没有跨域限制的，我们利用这一点，绕过 ajax 引擎，从而解决跨域请求\n<!--more-->\n+ 使用 node.js 建立服务\n\n\t\tconst http = require('http'); // 导入http内置模块\n\t\n\t\tconst server = http.createServer() // 创建一个http服务\n\n\t\tserver.on('request', function(req, res){ // 监听http服务器的request请求\n\t\t\tconst url = req.url  // 获取请求的url\n\t\t\tif (url === '/xxxxxx') {\n\t\t\t\tvar scriptStr = 'show()';  // 拼接一个合法的js脚本(前端事先声明好的方法的调用)\n\t\t\t\tres.end(scriptStr)；  // res.end发送给客户端，客户端去把这个字符串，当作js代码去解析执行\n\t\t\t} else {\n\t\t\t\tres.end('404 Not Found!')；\n\t\t\t}\n\t\t})\n\t\t\n\t\tserver.listen(3000, function(){ // 指定端口号并启动服务器监听\n\t\t\tconsole.log('server listen at http://127.0.0.1:3000')；\n\t\t})\n\n+ 前端书写规范\n\n\t\t<script type=\"text/javascript\">\n\t\t\tfunction show (data) { // 事先声明好一个处理请求的回调函数，供服务器触发\n\t\t\t\t// 处理请求的逻辑\n\t\t\t\tconsole.log(data)\n\t\t\t}\n\t\t</script>\n\n\t\t<script src=\"http://127.0.0.1:3000/xxxxxx\"></script>\n\n> 注意：以上方法，写死了show()方法，不能动态处理请求，升级改造如下：\n\n+ node.js服务升级\n\n\t\tconst http = require('http');\n\t\n\t\tconst urlModule = require('url');  // 引入url模块，这个模块能够帮我们解析URL地址，从而拿到 pathname,query\n\n\t\tconst server = http.createServer();  \n\n\t\tserver.on('request', function(req, res){\n\t\t\t// const url = req.url;\n\t\t\t// const { pathname, query } = urlModule.parse(req.url, true); // 获取请求的url\n\t\t\tconst { pathname: url, query } = urlModule.parse(req.url, true); // 获取请求的url,并将pathname重命名为url\n\n\t\t\tif (url === '/xxxxxx') {\n\t\t\t\tvar resData = { // 新增数据对象\n\t\t\t\t\tname: 'xxx',\n\t\t\t\t\tage: 18\n\t\t\t\t}\n\t\t\t\t// var scriptStr = 'show()';\n\t\t\t\tvar scriptStr = `${query.callback}(${JSON.stringify(resData)})`; // 修改返回值,query.callback就能取到前端callbak对应的函数名\n\t\t\t\tres.end(scriptStr)；\n\t\t\t} else {\n\t\t\t\tres.end('404 Not Found!')；\n\t\t\t}\n\t\t})\n\t\t\n\t\tserver.listen(3000, function(){\n\t\t\tconsole.log('server listen at http://127.0.0.1:3000')；\n\t\t})\n\n+ 前端编码升级\n\n\t\t<script type=\"text/javascript\">\n\t\t\tfunction showInfo (data) { // 事先声明好一个处理请求的回调函数，供服务器触发\n\t\t\t\t// 处理请求的逻辑\n\t\t\t\tconsole.log(data)\n\t\t\t}\n\t\t</script>\n\n\t\t<script src=\"http://127.0.0.1:3000/xxxxxx?callback=showInfo\"></script>\n\n##### 2. CORS解决跨域\n\n详解可参考阮一峰的 [跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n\n服务端设置响应头 ` Access-Control-Allow-Origin `\n\t\n\tAccess-Control-Allow-Origin： http://api.bob.com； // 只允许http://api.bob.com跨域请求\n\tAccess-Control-Allow-Origin： *；  // 所以的请求都允许跨域请求","source":"_posts/2019-01-11-前后端交互之跨域问题-md.md","raw":"---\ntitle: 前后端交互之跨域问题\ndate: 2019-01-11 19:13:13\ntags: js\n---\n#### 前后端交互之跨域问题\n跨域出现的原因：浏览器为安全性考虑而实施的同源策略\t，当协议名，域名，端口号三者中任一一种不相同，就会产生跨域问题。\n\n##### 1. jsonp解决跨域\n> 在 HTML 标签里，一些诸如 script、img 这样的资源的标签是没有跨域限制的，我们利用这一点，绕过 ajax 引擎，从而解决跨域请求\n<!--more-->\n+ 使用 node.js 建立服务\n\n\t\tconst http = require('http'); // 导入http内置模块\n\t\n\t\tconst server = http.createServer() // 创建一个http服务\n\n\t\tserver.on('request', function(req, res){ // 监听http服务器的request请求\n\t\t\tconst url = req.url  // 获取请求的url\n\t\t\tif (url === '/xxxxxx') {\n\t\t\t\tvar scriptStr = 'show()';  // 拼接一个合法的js脚本(前端事先声明好的方法的调用)\n\t\t\t\tres.end(scriptStr)；  // res.end发送给客户端，客户端去把这个字符串，当作js代码去解析执行\n\t\t\t} else {\n\t\t\t\tres.end('404 Not Found!')；\n\t\t\t}\n\t\t})\n\t\t\n\t\tserver.listen(3000, function(){ // 指定端口号并启动服务器监听\n\t\t\tconsole.log('server listen at http://127.0.0.1:3000')；\n\t\t})\n\n+ 前端书写规范\n\n\t\t<script type=\"text/javascript\">\n\t\t\tfunction show (data) { // 事先声明好一个处理请求的回调函数，供服务器触发\n\t\t\t\t// 处理请求的逻辑\n\t\t\t\tconsole.log(data)\n\t\t\t}\n\t\t</script>\n\n\t\t<script src=\"http://127.0.0.1:3000/xxxxxx\"></script>\n\n> 注意：以上方法，写死了show()方法，不能动态处理请求，升级改造如下：\n\n+ node.js服务升级\n\n\t\tconst http = require('http');\n\t\n\t\tconst urlModule = require('url');  // 引入url模块，这个模块能够帮我们解析URL地址，从而拿到 pathname,query\n\n\t\tconst server = http.createServer();  \n\n\t\tserver.on('request', function(req, res){\n\t\t\t// const url = req.url;\n\t\t\t// const { pathname, query } = urlModule.parse(req.url, true); // 获取请求的url\n\t\t\tconst { pathname: url, query } = urlModule.parse(req.url, true); // 获取请求的url,并将pathname重命名为url\n\n\t\t\tif (url === '/xxxxxx') {\n\t\t\t\tvar resData = { // 新增数据对象\n\t\t\t\t\tname: 'xxx',\n\t\t\t\t\tage: 18\n\t\t\t\t}\n\t\t\t\t// var scriptStr = 'show()';\n\t\t\t\tvar scriptStr = `${query.callback}(${JSON.stringify(resData)})`; // 修改返回值,query.callback就能取到前端callbak对应的函数名\n\t\t\t\tres.end(scriptStr)；\n\t\t\t} else {\n\t\t\t\tres.end('404 Not Found!')；\n\t\t\t}\n\t\t})\n\t\t\n\t\tserver.listen(3000, function(){\n\t\t\tconsole.log('server listen at http://127.0.0.1:3000')；\n\t\t})\n\n+ 前端编码升级\n\n\t\t<script type=\"text/javascript\">\n\t\t\tfunction showInfo (data) { // 事先声明好一个处理请求的回调函数，供服务器触发\n\t\t\t\t// 处理请求的逻辑\n\t\t\t\tconsole.log(data)\n\t\t\t}\n\t\t</script>\n\n\t\t<script src=\"http://127.0.0.1:3000/xxxxxx?callback=showInfo\"></script>\n\n##### 2. CORS解决跨域\n\n详解可参考阮一峰的 [跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n\n服务端设置响应头 ` Access-Control-Allow-Origin `\n\t\n\tAccess-Control-Allow-Origin： http://api.bob.com； // 只允许http://api.bob.com跨域请求\n\tAccess-Control-Allow-Origin： *；  // 所以的请求都允许跨域请求","slug":"2019-01-11-前后端交互之跨域问题-md","published":1,"updated":"2019-03-20T14:21:56.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7gup000ggp9acl4zir9v","content":"<h4 id=\"前后端交互之跨域问题\"><a href=\"#前后端交互之跨域问题\" class=\"headerlink\" title=\"前后端交互之跨域问题\"></a>前后端交互之跨域问题</h4><p>跨域出现的原因：浏览器为安全性考虑而实施的同源策略    ，当协议名，域名，端口号三者中任一一种不相同，就会产生跨域问题。</p>\n<h5 id=\"1-jsonp解决跨域\"><a href=\"#1-jsonp解决跨域\" class=\"headerlink\" title=\"1. jsonp解决跨域\"></a>1. jsonp解决跨域</h5><blockquote>\n<p>在 HTML 标签里，一些诸如 script、img 这样的资源的标签是没有跨域限制的，我们利用这一点，绕过 ajax 引擎，从而解决跨域请求<br><a id=\"more\"></a></p>\n<ul>\n<li>使用 node.js 建立服务</li>\n</ul>\n</blockquote>\n<pre><code>const http = require(&apos;http&apos;); // 导入http内置模块\n\nconst server = http.createServer() // 创建一个http服务\n\nserver.on(&apos;request&apos;, function(req, res){ // 监听http服务器的request请求\n    const url = req.url  // 获取请求的url\n    if (url === &apos;/xxxxxx&apos;) {\n        var scriptStr = &apos;show()&apos;;  // 拼接一个合法的js脚本(前端事先声明好的方法的调用)\n        res.end(scriptStr)；  // res.end发送给客户端，客户端去把这个字符串，当作js代码去解析执行\n    } else {\n        res.end(&apos;404 Not Found!&apos;)；\n    }\n})\n\nserver.listen(3000, function(){ // 指定端口号并启动服务器监听\n    console.log(&apos;server listen at http://127.0.0.1:3000&apos;)；\n})\n</code></pre><ul>\n<li><p>前端书写规范</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    function show (data) { // 事先声明好一个处理请求的回调函数，供服务器触发\n        // 处理请求的逻辑\n        console.log(data)\n    }\n&lt;/script&gt;\n\n&lt;script src=&quot;http://127.0.0.1:3000/xxxxxx&quot;&gt;&lt;/script&gt;\n</code></pre></li>\n</ul>\n<blockquote>\n<p>注意：以上方法，写死了show()方法，不能动态处理请求，升级改造如下：</p>\n</blockquote>\n<ul>\n<li><p>node.js服务升级</p>\n<pre><code>const http = require(&apos;http&apos;);\n\nconst urlModule = require(&apos;url&apos;);  // 引入url模块，这个模块能够帮我们解析URL地址，从而拿到 pathname,query\n\nconst server = http.createServer();  \n\nserver.on(&apos;request&apos;, function(req, res){\n    // const url = req.url;\n    // const { pathname, query } = urlModule.parse(req.url, true); // 获取请求的url\n    const { pathname: url, query } = urlModule.parse(req.url, true); // 获取请求的url,并将pathname重命名为url\n\n    if (url === &apos;/xxxxxx&apos;) {\n        var resData = { // 新增数据对象\n            name: &apos;xxx&apos;,\n            age: 18\n        }\n        // var scriptStr = &apos;show()&apos;;\n        var scriptStr = `${query.callback}(${JSON.stringify(resData)})`; // 修改返回值,query.callback就能取到前端callbak对应的函数名\n        res.end(scriptStr)；\n    } else {\n        res.end(&apos;404 Not Found!&apos;)；\n    }\n})\n\nserver.listen(3000, function(){\n    console.log(&apos;server listen at http://127.0.0.1:3000&apos;)；\n})\n</code></pre></li>\n<li><p>前端编码升级</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    function showInfo (data) { // 事先声明好一个处理请求的回调函数，供服务器触发\n        // 处理请求的逻辑\n        console.log(data)\n    }\n&lt;/script&gt;\n\n&lt;script src=&quot;http://127.0.0.1:3000/xxxxxx?callback=showInfo&quot;&gt;&lt;/script&gt;\n</code></pre></li>\n</ul>\n<h5 id=\"2-CORS解决跨域\"><a href=\"#2-CORS解决跨域\" class=\"headerlink\" title=\"2. CORS解决跨域\"></a>2. CORS解决跨域</h5><p>详解可参考阮一峰的 <a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">跨域资源共享 CORS 详解</a></p>\n<p>服务端设置响应头 <code>Access-Control-Allow-Origin</code></p>\n<pre><code>Access-Control-Allow-Origin： http://api.bob.com； // 只允许http://api.bob.com跨域请求\nAccess-Control-Allow-Origin： *；  // 所以的请求都允许跨域请求\n</code></pre>","site":{"data":{}},"excerpt":"<h4 id=\"前后端交互之跨域问题\"><a href=\"#前后端交互之跨域问题\" class=\"headerlink\" title=\"前后端交互之跨域问题\"></a>前后端交互之跨域问题</h4><p>跨域出现的原因：浏览器为安全性考虑而实施的同源策略    ，当协议名，域名，端口号三者中任一一种不相同，就会产生跨域问题。</p>\n<h5 id=\"1-jsonp解决跨域\"><a href=\"#1-jsonp解决跨域\" class=\"headerlink\" title=\"1. jsonp解决跨域\"></a>1. jsonp解决跨域</h5><blockquote>\n<p>在 HTML 标签里，一些诸如 script、img 这样的资源的标签是没有跨域限制的，我们利用这一点，绕过 ajax 引擎，从而解决跨域请求<br></p></blockquote>","more":"</p>\n<ul>\n<li>使用 node.js 建立服务</li>\n</ul>\n</blockquote>\n<pre><code>const http = require(&apos;http&apos;); // 导入http内置模块\n\nconst server = http.createServer() // 创建一个http服务\n\nserver.on(&apos;request&apos;, function(req, res){ // 监听http服务器的request请求\n    const url = req.url  // 获取请求的url\n    if (url === &apos;/xxxxxx&apos;) {\n        var scriptStr = &apos;show()&apos;;  // 拼接一个合法的js脚本(前端事先声明好的方法的调用)\n        res.end(scriptStr)；  // res.end发送给客户端，客户端去把这个字符串，当作js代码去解析执行\n    } else {\n        res.end(&apos;404 Not Found!&apos;)；\n    }\n})\n\nserver.listen(3000, function(){ // 指定端口号并启动服务器监听\n    console.log(&apos;server listen at http://127.0.0.1:3000&apos;)；\n})\n</code></pre><ul>\n<li><p>前端书写规范</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    function show (data) { // 事先声明好一个处理请求的回调函数，供服务器触发\n        // 处理请求的逻辑\n        console.log(data)\n    }\n&lt;/script&gt;\n\n&lt;script src=&quot;http://127.0.0.1:3000/xxxxxx&quot;&gt;&lt;/script&gt;\n</code></pre></li>\n</ul>\n<blockquote>\n<p>注意：以上方法，写死了show()方法，不能动态处理请求，升级改造如下：</p>\n</blockquote>\n<ul>\n<li><p>node.js服务升级</p>\n<pre><code>const http = require(&apos;http&apos;);\n\nconst urlModule = require(&apos;url&apos;);  // 引入url模块，这个模块能够帮我们解析URL地址，从而拿到 pathname,query\n\nconst server = http.createServer();  \n\nserver.on(&apos;request&apos;, function(req, res){\n    // const url = req.url;\n    // const { pathname, query } = urlModule.parse(req.url, true); // 获取请求的url\n    const { pathname: url, query } = urlModule.parse(req.url, true); // 获取请求的url,并将pathname重命名为url\n\n    if (url === &apos;/xxxxxx&apos;) {\n        var resData = { // 新增数据对象\n            name: &apos;xxx&apos;,\n            age: 18\n        }\n        // var scriptStr = &apos;show()&apos;;\n        var scriptStr = `${query.callback}(${JSON.stringify(resData)})`; // 修改返回值,query.callback就能取到前端callbak对应的函数名\n        res.end(scriptStr)；\n    } else {\n        res.end(&apos;404 Not Found!&apos;)；\n    }\n})\n\nserver.listen(3000, function(){\n    console.log(&apos;server listen at http://127.0.0.1:3000&apos;)；\n})\n</code></pre></li>\n<li><p>前端编码升级</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    function showInfo (data) { // 事先声明好一个处理请求的回调函数，供服务器触发\n        // 处理请求的逻辑\n        console.log(data)\n    }\n&lt;/script&gt;\n\n&lt;script src=&quot;http://127.0.0.1:3000/xxxxxx?callback=showInfo&quot;&gt;&lt;/script&gt;\n</code></pre></li>\n</ul>\n<h5 id=\"2-CORS解决跨域\"><a href=\"#2-CORS解决跨域\" class=\"headerlink\" title=\"2. CORS解决跨域\"></a>2. CORS解决跨域</h5><p>详解可参考阮一峰的 <a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">跨域资源共享 CORS 详解</a></p>\n<p>服务端设置响应头 <code>Access-Control-Allow-Origin</code></p>\n<pre><code>Access-Control-Allow-Origin： http://api.bob.com； // 只允许http://api.bob.com跨域请求\nAccess-Control-Allow-Origin： *；  // 所以的请求都允许跨域请求\n</code></pre>"},{"title":"hello","date":"2019-03-17T11:13:13.000Z","_content":"#### hello hexo","source":"_posts/2019-03-17-hello-md.md","raw":"---\ntitle: hello\ndate: 2019-03-17 19:13:13\ntags:\n---\n#### hello hexo","slug":"2019-03-17-hello-md","published":1,"updated":"2019-03-18T14:42:07.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7guq000igp9auiqpocvd","content":"<h4 id=\"hello-hexo\"><a href=\"#hello-hexo\" class=\"headerlink\" title=\"hello hexo\"></a>hello hexo</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"hello-hexo\"><a href=\"#hello-hexo\" class=\"headerlink\" title=\"hello hexo\"></a>hello hexo</h4>"},{"title":"node.js学习笔记之入门","date":"2019-04-15T12:51:35.000Z","_content":"\n### 1. Node.js介绍  \n#### 1.1 Node.js是什么？\n+ Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.\n\t+ node.js 不是一门语言\n\t+ node.js 不是库，不是框架\n\t+ node.js 是一个javascript运行时环境\n\t+ 简单来讲，Node.js可以解析和执行js代码\n\t<!-- more -->\n\t+ 以前只有浏览器可以解析之行javascript代码\n\t+ 也就是说现在的javascript可以完全脱离浏览器来运行，一切都归功于Node.js\n\t+ 构建于 Chrome 的 V8 引擎之上\n\t\t+ 代码只是具有特定格式的字符串而已\n\t\t+ 引擎可以认识它，可以帮你去解析和执行\n\t\t+ Google Chrome 的 V8 引擎是目前公认解析 JavaScript 最快的\n\t\t+ Node.js 之所以很快的原因之一是：Node.js的作者，将Google Chrome 中的 V8 引擎移植了出来，开发了一个独立的 javaScript 运行时环境\n+ Node.js uses an event-driven, non-blockling I/O model that makes it leightweight and efficient\n\t+ event-driven 时间驱动\n\t+ non-blocking I/O model 非阻塞I/O模型（异步）\n\t+ lightweidht and efficient 轻量和高效\n\n+ Node.js package ecosystem, npm is the largest ecosystem of open source libraiies in the word\n\t+ npm 是世界上最大的开源生态系统\n\t+ 绝大多数的javascript相关的包都放在了npm上，这样做的目的是让开发人员更方便的去开发使用它\n\t+ `npm install jquery`  \n\n\t\n#### 1.2 \t浏览器中的js和Node.js中的js的区别\n+ 浏览器中的javascript\n\t+ EcmaScript\n\t\t+ 基本语法\n\t\t+ if\n\t\t+ var\n\t\t+ function\n\t\t+ Object\n\t\t+ Array\n\t+ BOM\n\t+ DOM\n+ Node.js中的javascript\n\t+ 没有BOM,DOM(浏览器不操作BOM,DOM)\n\t+ EcmaScript\n\t+ 在Node这个javaScript执行环境中为javaScript提供了一些服务器级别的操作API\n\t\t+ 例如文件的读写\n\t\t+ 网络服务的构建\n\t\t+ 网络通信\n\t\t+ http服务器\n\t\t+ 等的处理...","source":"_posts/node-js学习笔记之入门-md.md","raw":"---\ntitle: node.js学习笔记之入门\ndate: 2019-04-15 20:51:35\ntags: Node.js\n---\n\n### 1. Node.js介绍  \n#### 1.1 Node.js是什么？\n+ Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.\n\t+ node.js 不是一门语言\n\t+ node.js 不是库，不是框架\n\t+ node.js 是一个javascript运行时环境\n\t+ 简单来讲，Node.js可以解析和执行js代码\n\t<!-- more -->\n\t+ 以前只有浏览器可以解析之行javascript代码\n\t+ 也就是说现在的javascript可以完全脱离浏览器来运行，一切都归功于Node.js\n\t+ 构建于 Chrome 的 V8 引擎之上\n\t\t+ 代码只是具有特定格式的字符串而已\n\t\t+ 引擎可以认识它，可以帮你去解析和执行\n\t\t+ Google Chrome 的 V8 引擎是目前公认解析 JavaScript 最快的\n\t\t+ Node.js 之所以很快的原因之一是：Node.js的作者，将Google Chrome 中的 V8 引擎移植了出来，开发了一个独立的 javaScript 运行时环境\n+ Node.js uses an event-driven, non-blockling I/O model that makes it leightweight and efficient\n\t+ event-driven 时间驱动\n\t+ non-blocking I/O model 非阻塞I/O模型（异步）\n\t+ lightweidht and efficient 轻量和高效\n\n+ Node.js package ecosystem, npm is the largest ecosystem of open source libraiies in the word\n\t+ npm 是世界上最大的开源生态系统\n\t+ 绝大多数的javascript相关的包都放在了npm上，这样做的目的是让开发人员更方便的去开发使用它\n\t+ `npm install jquery`  \n\n\t\n#### 1.2 \t浏览器中的js和Node.js中的js的区别\n+ 浏览器中的javascript\n\t+ EcmaScript\n\t\t+ 基本语法\n\t\t+ if\n\t\t+ var\n\t\t+ function\n\t\t+ Object\n\t\t+ Array\n\t+ BOM\n\t+ DOM\n+ Node.js中的javascript\n\t+ 没有BOM,DOM(浏览器不操作BOM,DOM)\n\t+ EcmaScript\n\t+ 在Node这个javaScript执行环境中为javaScript提供了一些服务器级别的操作API\n\t\t+ 例如文件的读写\n\t\t+ 网络服务的构建\n\t\t+ 网络通信\n\t\t+ http服务器\n\t\t+ 等的处理...","slug":"node-js学习笔记之入门-md","published":1,"updated":"2019-04-15T13:53:37.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7gur000lgp9ah2kq8k0p","content":"<h3 id=\"1-Node-js介绍\"><a href=\"#1-Node-js介绍\" class=\"headerlink\" title=\"1. Node.js介绍\"></a>1. Node.js介绍</h3><h4 id=\"1-1-Node-js是什么？\"><a href=\"#1-1-Node-js是什么？\" class=\"headerlink\" title=\"1.1 Node.js是什么？\"></a>1.1 Node.js是什么？</h4><ul>\n<li>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.<ul>\n<li>node.js 不是一门语言</li>\n<li>node.js 不是库，不是框架</li>\n<li>node.js 是一个javascript运行时环境</li>\n<li>简单来讲，Node.js可以解析和执行js代码<a id=\"more\"></a></li>\n<li>以前只有浏览器可以解析之行javascript代码</li>\n<li>也就是说现在的javascript可以完全脱离浏览器来运行，一切都归功于Node.js</li>\n<li>构建于 Chrome 的 V8 引擎之上<ul>\n<li>代码只是具有特定格式的字符串而已</li>\n<li>引擎可以认识它，可以帮你去解析和执行</li>\n<li>Google Chrome 的 V8 引擎是目前公认解析 JavaScript 最快的</li>\n<li>Node.js 之所以很快的原因之一是：Node.js的作者，将Google Chrome 中的 V8 引擎移植了出来，开发了一个独立的 javaScript 运行时环境</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Node.js uses an event-driven, non-blockling I/O model that makes it leightweight and efficient</p>\n<ul>\n<li>event-driven 时间驱动</li>\n<li>non-blocking I/O model 非阻塞I/O模型（异步）</li>\n<li>lightweidht and efficient 轻量和高效</li>\n</ul>\n</li>\n<li><p>Node.js package ecosystem, npm is the largest ecosystem of open source libraiies in the word</p>\n<ul>\n<li>npm 是世界上最大的开源生态系统</li>\n<li>绝大多数的javascript相关的包都放在了npm上，这样做的目的是让开发人员更方便的去开发使用它</li>\n<li><code>npm install jquery</code>  </li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-2-浏览器中的js和Node-js中的js的区别\"><a href=\"#1-2-浏览器中的js和Node-js中的js的区别\" class=\"headerlink\" title=\"1.2     浏览器中的js和Node.js中的js的区别\"></a>1.2     浏览器中的js和Node.js中的js的区别</h4><ul>\n<li>浏览器中的javascript<ul>\n<li>EcmaScript<ul>\n<li>基本语法</li>\n<li>if</li>\n<li>var</li>\n<li>function</li>\n<li>Object</li>\n<li>Array</li>\n</ul>\n</li>\n<li>BOM</li>\n<li>DOM</li>\n</ul>\n</li>\n<li>Node.js中的javascript<ul>\n<li>没有BOM,DOM(浏览器不操作BOM,DOM)</li>\n<li>EcmaScript</li>\n<li>在Node这个javaScript执行环境中为javaScript提供了一些服务器级别的操作API<ul>\n<li>例如文件的读写</li>\n<li>网络服务的构建</li>\n<li>网络通信</li>\n<li>http服务器</li>\n<li>等的处理…</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-Node-js介绍\"><a href=\"#1-Node-js介绍\" class=\"headerlink\" title=\"1. Node.js介绍\"></a>1. Node.js介绍</h3><h4 id=\"1-1-Node-js是什么？\"><a href=\"#1-1-Node-js是什么？\" class=\"headerlink\" title=\"1.1 Node.js是什么？\"></a>1.1 Node.js是什么？</h4><ul>\n<li>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.<ul>\n<li>node.js 不是一门语言</li>\n<li>node.js 不是库，不是框架</li>\n<li>node.js 是一个javascript运行时环境</li>\n<li>简单来讲，Node.js可以解析和执行js代码</li></ul></li></ul>","more":"</li>\n<li>以前只有浏览器可以解析之行javascript代码</li>\n<li>也就是说现在的javascript可以完全脱离浏览器来运行，一切都归功于Node.js</li>\n<li>构建于 Chrome 的 V8 引擎之上<ul>\n<li>代码只是具有特定格式的字符串而已</li>\n<li>引擎可以认识它，可以帮你去解析和执行</li>\n<li>Google Chrome 的 V8 引擎是目前公认解析 JavaScript 最快的</li>\n<li>Node.js 之所以很快的原因之一是：Node.js的作者，将Google Chrome 中的 V8 引擎移植了出来，开发了一个独立的 javaScript 运行时环境</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Node.js uses an event-driven, non-blockling I/O model that makes it leightweight and efficient</p>\n<ul>\n<li>event-driven 时间驱动</li>\n<li>non-blocking I/O model 非阻塞I/O模型（异步）</li>\n<li>lightweidht and efficient 轻量和高效</li>\n</ul>\n</li>\n<li><p>Node.js package ecosystem, npm is the largest ecosystem of open source libraiies in the word</p>\n<ul>\n<li>npm 是世界上最大的开源生态系统</li>\n<li>绝大多数的javascript相关的包都放在了npm上，这样做的目的是让开发人员更方便的去开发使用它</li>\n<li><code>npm install jquery</code>  </li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-2-浏览器中的js和Node-js中的js的区别\"><a href=\"#1-2-浏览器中的js和Node-js中的js的区别\" class=\"headerlink\" title=\"1.2     浏览器中的js和Node.js中的js的区别\"></a>1.2     浏览器中的js和Node.js中的js的区别</h4><ul>\n<li>浏览器中的javascript<ul>\n<li>EcmaScript<ul>\n<li>基本语法</li>\n<li>if</li>\n<li>var</li>\n<li>function</li>\n<li>Object</li>\n<li>Array</li>\n</ul>\n</li>\n<li>BOM</li>\n<li>DOM</li>\n</ul>\n</li>\n<li>Node.js中的javascript<ul>\n<li>没有BOM,DOM(浏览器不操作BOM,DOM)</li>\n<li>EcmaScript</li>\n<li>在Node这个javaScript执行环境中为javaScript提供了一些服务器级别的操作API<ul>\n<li>例如文件的读写</li>\n<li>网络服务的构建</li>\n<li>网络通信</li>\n<li>http服务器</li>\n<li>等的处理…</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"js对字符串的操作","date":"2017-08-05T11:13:13.000Z","_content":"## js对字符串的操作\n\n### 1. 将其它类型的数据转换为字符串\n> 语法：  \n> 可以调用 stringObj.toString() 方法，String(stringObj) 方法，或者饮食转化 \"\" + stringObj;  \n> 使用如下：   \n\n<!--more-->\n\n\tvar num = 19;\n\tvar numStr0 = num.toString();\n\tvar numStr1 = String(num);\n\tvar numStr2 = '' + num;\n\n### 2. 获取字符串的长度\n> 语法：  \n> stringObj.length\n\n\tvar str = 'javaScript';\n\tconsole.log(str.length); // 10\n\n### 3. 字符串替换\n> 语法：  \n> stringObj.replace(rgExp, replaceText)，返回替换后的字符串，原字符串不变，参数说明如下：  \n> reExp可以是正则表达式对象(RegExp)，也可以是字符串(string)，replaceText是替代的查找到的字符串；  \n> 使用如下：  \n\n\tvar str = 'php是世界上最好的语言';\n\tvar strRes = str.replace('php', 'javascript才');\n\tconsole.log(str + '?开玩笑，' + strRes);\n\n### 4. 查找给定位置的字符或其字符编码值\n> 语法：  \n> 1. 查找指定位置的字符： stringObj.charAt(index)，返回查找到的字符，不影响原数组；  \n> 参数解析，index为要查找的指定位置字符的下标索引。\n> 2. 查找指定位置字符的字符编码值，stringObj.charCodeAt(index)  \n\n\t// 获取指定位置的字符\n\tvar str = 'javaScript';\n\tvar strCharAt = str.charAt(6);\n\tvar strCharCodeAt = str.charCodeAt(6);\n\tconsole.log(str+\"的第7位字符是:\"+strCharAt+\",其字符编码值为：\"+strCharCodeAt); // javaScript的第7位字符是:r,其字符编码值为：114\n\n### 5. 字符串连接  \n> 语法：  \n> 1. 直接使用 + ，  \n> 2. stringObj.concat(stringObj2)，返回拼接后的字符串，对原字符串无影响   \n\n\tvar firstStr = 'java';\n\tvar lastStr = 'script';\n\tvar strRes = firstStr.concat(lastStr);\n\tconsole.log(strRes+\"是由字符串\"+firstStr+'和'+lastStr+'拼接而成的'); // javascript是由字符串java和script拼接而成的\n\n### 6. 字符串的切割和提取\n> 语法：  \n> 1. stringObj.slice(start, end)，返回截取得到的字符串，不影响原字符串，  \n> 2. stringObj.substring(start, end)，返回截取得到的字符串，不影响原字符串，  \n> 3. stringObj.substr(start, end)，返回截取得到的字符串，不影响原字符串。  \n> 参数解析：  \n> 1. 对于slice()和substring()方法而言：\n> start： 必选，非负，指定开始位置的下标，  \n> end: 可选，非负，指定结束位置的下标，不传，默认到字符串末尾，  \n> 返回的子串包括 start 处的字符，但不包括 stop 处的字符。  \n> 2. 对于substr()方法而言：  \n> start: 必选，非负，指定开始位置的下标，  \n> end: 可选，非负，指定截取的最大长度，不传，默认到字符串结尾。  \n> 3. 对于三种方法而言，参数end如果是一个大于字符串长度的值，则截取到字符串结尾终止\n\n\tvar str = 'javaScript';\n\tvar sliceStr0 = str.slice(1, 5);\n\tvar sliceStr1 = str.slice(1, 15);\n\tvar substringStr0 = str.substring(1, 5);\n\tvar substringStr1 = str.substring(1, 15);\n\tvar substrStr0 = str.substr(1, 5);\n\tvar substrStr1 = str.substr(1, 15);\n\tconsole.log(str); // javascript\n\tconsole.log(sliceStr0); // avaS\n\tconsole.log(sliceStr1); // avaScript\n\tconsole.log(substringStr0); // avaS\n\tconsole.log(substringStr1); // avaScript\n\tconsole.log(substrStr0); // avaSc\n\tconsole.log(substrStr1); // avaScript\n\n### 8. 字符串大小写转换\n> 语法：  \n> stringObj.toLowerCase(): 将字符串转换为小写，返回被转换之后的字符串，不影响原字符串。  \n> stringObj.toLocaleLowerCase(): 将字符串转换为小写，返回被转换之后的字符串，不影响原字符串。  \n> stringObj.toUpperCase(): 将字符串转换为大写，返回被转换之后的字符串，不影响原字符串。  \n> stringObj.toLocaleUpperCase(): 将字符串转换为大写，返回被转换之后的字符串，不影响原字符串。  \n\n\tvar str = 'JavaScript';\n\tvar lowerCase = str.toLowerCase();\n\tvar localLowerCase = str.toLocaleLowerCase();\n\tconsole.log(str+\"转化为小写为：\"+lowerCase); // JavaScript转化为小写为：javascript\n\tconsole.log(str+\"转化为小写为：\"+localLowerCase); // JavaScript转化为小写为：javascript\n\tvar upperCase = str.toUpperCase();\n\tvar localUpperCase = str.toLocaleUpperCase();\n\tconsole.log(str+\"转化为大写为：\"+upperCase); // JavaScript转化为大写为：JAVASCRIPT\n\tconsole.log(str+\"转化为大写为：\"+localUpperCase); // JavaScript转化为大写为：JAVASCRIPT\n\n### 7. 把字符串分割成数组 —— split()\n> 用法： stringObject.split(separator,howmany)  \n> separator：必选，类型为字符串或者数组，指定要切割的地方。(返回数组含用来指定切割的字符)  \n> howmany：可选择，返回数组的最大长度。\n\n\tvar str1 = 'JavaScript';\n\tconsole.log(str1.split('')); // [\"J\", \"a\", \"v\", \"a\", \"S\", \"c\", \"r\", \"i\", \"p\", \"t\"]\n\tconsole.log(str1.split('', 6)); // [\"J\", \"a\", \"v\", \"a\", \"S\", \"c\"]\n\tconsole.log(str1.split('', 20)); // [\"J\", \"a\", \"v\", \"a\", \"S\", \"c\", \"r\", \"i\", \"p\", \"t\"]\n\n\tvar str2 = 'Java Script';\n\tconsole.log(str2.split(/\\s+/)); // [\"Java\", \"Script\"]\n\n### 8. 查询字符串\n> 语法：  \n> stringOb.indexOf(searchvalue,fromindex),从字符串的开头开始查找，找到返回对应的下标，找不到返回-1，此方法对大小写敏感。  \n> stringOb.lastIndexOf(searchvalue,fromindex),从字符串的末尾开始查找，找到返回对应的下标，找不到返回-1，此方法对大小写敏感。  \n> 参数解析：  \n> 相同点：  \n> searchvalue：必须，规定检索的字符串值  \n> 不同点：  \n> indexOf()方法中参数fromindex：可选，开始检索的地方，从哪开始查找，合法取值：0—stringObject.length，当然不合法取个负值也是不会报错的只是会被视作0或者说空  \n> lastIndexOf()方法中的参数fromindex：可选，建议不填，奇妙的第二个参数，能不用就不用\n\n\tvar str1 = 'Java Script';\n\tconsole.log(str1.indexOf('a')); // 1\n\tconsole.log(str1.lastIndexOf('a')); // 3\n\tconsole.log(str1.indexOf('a', 1)); // 1\n\tconsole.log(str1.lastIndexOf('a', 1)); // 1\n\tconsole.log(str1.indexOf('a', 2)); // 3\n\tconsole.log(str1.lastIndexOf('a', 1)); // 1\n\n> 注：调用此方法，要查询的指定字符若存在于目标字符串中，则返回对应的下标，若不存在，则返回 -1 ，可根据此特性，来判断某一字符串中是否含有某一指定字符，如：   \n\n\t// 判断str1中是否含有字符'a'\n\tvar str1 = 'Java Script';\n\tfunction checkStr (targetStr) {\n\t  if (str1.indexOf(targetStr) > -1) {\n\t    alert('str1中含有字符'+targetStr);\n\t  } else {\n\t    alert('str1中不含有字符'+targetStr);\n\t  }\n\t}\n\t// 检查是否含有字符'a'\n\tcheckStr('a');\n\t// 检查是否含有字符'abc'\n\tcheckStr('abc');\n\n### 9. 面试题\n\t\n\tfunction getSuffix(file){\n      return file.slice(file.lastIndexOf(\".\") + 1,file.length); \n\t}\n\n\tconsole.log(getSuffix('test.min.js')); // js","source":"_posts/2017-08-05-javascript基础之字符串操作.md","raw":"---\ntitle: js对字符串的操作\ndate: 2017-08-05 19:13:13\ntags: js\n---\n## js对字符串的操作\n\n### 1. 将其它类型的数据转换为字符串\n> 语法：  \n> 可以调用 stringObj.toString() 方法，String(stringObj) 方法，或者饮食转化 \"\" + stringObj;  \n> 使用如下：   \n\n<!--more-->\n\n\tvar num = 19;\n\tvar numStr0 = num.toString();\n\tvar numStr1 = String(num);\n\tvar numStr2 = '' + num;\n\n### 2. 获取字符串的长度\n> 语法：  \n> stringObj.length\n\n\tvar str = 'javaScript';\n\tconsole.log(str.length); // 10\n\n### 3. 字符串替换\n> 语法：  \n> stringObj.replace(rgExp, replaceText)，返回替换后的字符串，原字符串不变，参数说明如下：  \n> reExp可以是正则表达式对象(RegExp)，也可以是字符串(string)，replaceText是替代的查找到的字符串；  \n> 使用如下：  \n\n\tvar str = 'php是世界上最好的语言';\n\tvar strRes = str.replace('php', 'javascript才');\n\tconsole.log(str + '?开玩笑，' + strRes);\n\n### 4. 查找给定位置的字符或其字符编码值\n> 语法：  \n> 1. 查找指定位置的字符： stringObj.charAt(index)，返回查找到的字符，不影响原数组；  \n> 参数解析，index为要查找的指定位置字符的下标索引。\n> 2. 查找指定位置字符的字符编码值，stringObj.charCodeAt(index)  \n\n\t// 获取指定位置的字符\n\tvar str = 'javaScript';\n\tvar strCharAt = str.charAt(6);\n\tvar strCharCodeAt = str.charCodeAt(6);\n\tconsole.log(str+\"的第7位字符是:\"+strCharAt+\",其字符编码值为：\"+strCharCodeAt); // javaScript的第7位字符是:r,其字符编码值为：114\n\n### 5. 字符串连接  \n> 语法：  \n> 1. 直接使用 + ，  \n> 2. stringObj.concat(stringObj2)，返回拼接后的字符串，对原字符串无影响   \n\n\tvar firstStr = 'java';\n\tvar lastStr = 'script';\n\tvar strRes = firstStr.concat(lastStr);\n\tconsole.log(strRes+\"是由字符串\"+firstStr+'和'+lastStr+'拼接而成的'); // javascript是由字符串java和script拼接而成的\n\n### 6. 字符串的切割和提取\n> 语法：  \n> 1. stringObj.slice(start, end)，返回截取得到的字符串，不影响原字符串，  \n> 2. stringObj.substring(start, end)，返回截取得到的字符串，不影响原字符串，  \n> 3. stringObj.substr(start, end)，返回截取得到的字符串，不影响原字符串。  \n> 参数解析：  \n> 1. 对于slice()和substring()方法而言：\n> start： 必选，非负，指定开始位置的下标，  \n> end: 可选，非负，指定结束位置的下标，不传，默认到字符串末尾，  \n> 返回的子串包括 start 处的字符，但不包括 stop 处的字符。  \n> 2. 对于substr()方法而言：  \n> start: 必选，非负，指定开始位置的下标，  \n> end: 可选，非负，指定截取的最大长度，不传，默认到字符串结尾。  \n> 3. 对于三种方法而言，参数end如果是一个大于字符串长度的值，则截取到字符串结尾终止\n\n\tvar str = 'javaScript';\n\tvar sliceStr0 = str.slice(1, 5);\n\tvar sliceStr1 = str.slice(1, 15);\n\tvar substringStr0 = str.substring(1, 5);\n\tvar substringStr1 = str.substring(1, 15);\n\tvar substrStr0 = str.substr(1, 5);\n\tvar substrStr1 = str.substr(1, 15);\n\tconsole.log(str); // javascript\n\tconsole.log(sliceStr0); // avaS\n\tconsole.log(sliceStr1); // avaScript\n\tconsole.log(substringStr0); // avaS\n\tconsole.log(substringStr1); // avaScript\n\tconsole.log(substrStr0); // avaSc\n\tconsole.log(substrStr1); // avaScript\n\n### 8. 字符串大小写转换\n> 语法：  \n> stringObj.toLowerCase(): 将字符串转换为小写，返回被转换之后的字符串，不影响原字符串。  \n> stringObj.toLocaleLowerCase(): 将字符串转换为小写，返回被转换之后的字符串，不影响原字符串。  \n> stringObj.toUpperCase(): 将字符串转换为大写，返回被转换之后的字符串，不影响原字符串。  \n> stringObj.toLocaleUpperCase(): 将字符串转换为大写，返回被转换之后的字符串，不影响原字符串。  \n\n\tvar str = 'JavaScript';\n\tvar lowerCase = str.toLowerCase();\n\tvar localLowerCase = str.toLocaleLowerCase();\n\tconsole.log(str+\"转化为小写为：\"+lowerCase); // JavaScript转化为小写为：javascript\n\tconsole.log(str+\"转化为小写为：\"+localLowerCase); // JavaScript转化为小写为：javascript\n\tvar upperCase = str.toUpperCase();\n\tvar localUpperCase = str.toLocaleUpperCase();\n\tconsole.log(str+\"转化为大写为：\"+upperCase); // JavaScript转化为大写为：JAVASCRIPT\n\tconsole.log(str+\"转化为大写为：\"+localUpperCase); // JavaScript转化为大写为：JAVASCRIPT\n\n### 7. 把字符串分割成数组 —— split()\n> 用法： stringObject.split(separator,howmany)  \n> separator：必选，类型为字符串或者数组，指定要切割的地方。(返回数组含用来指定切割的字符)  \n> howmany：可选择，返回数组的最大长度。\n\n\tvar str1 = 'JavaScript';\n\tconsole.log(str1.split('')); // [\"J\", \"a\", \"v\", \"a\", \"S\", \"c\", \"r\", \"i\", \"p\", \"t\"]\n\tconsole.log(str1.split('', 6)); // [\"J\", \"a\", \"v\", \"a\", \"S\", \"c\"]\n\tconsole.log(str1.split('', 20)); // [\"J\", \"a\", \"v\", \"a\", \"S\", \"c\", \"r\", \"i\", \"p\", \"t\"]\n\n\tvar str2 = 'Java Script';\n\tconsole.log(str2.split(/\\s+/)); // [\"Java\", \"Script\"]\n\n### 8. 查询字符串\n> 语法：  \n> stringOb.indexOf(searchvalue,fromindex),从字符串的开头开始查找，找到返回对应的下标，找不到返回-1，此方法对大小写敏感。  \n> stringOb.lastIndexOf(searchvalue,fromindex),从字符串的末尾开始查找，找到返回对应的下标，找不到返回-1，此方法对大小写敏感。  \n> 参数解析：  \n> 相同点：  \n> searchvalue：必须，规定检索的字符串值  \n> 不同点：  \n> indexOf()方法中参数fromindex：可选，开始检索的地方，从哪开始查找，合法取值：0—stringObject.length，当然不合法取个负值也是不会报错的只是会被视作0或者说空  \n> lastIndexOf()方法中的参数fromindex：可选，建议不填，奇妙的第二个参数，能不用就不用\n\n\tvar str1 = 'Java Script';\n\tconsole.log(str1.indexOf('a')); // 1\n\tconsole.log(str1.lastIndexOf('a')); // 3\n\tconsole.log(str1.indexOf('a', 1)); // 1\n\tconsole.log(str1.lastIndexOf('a', 1)); // 1\n\tconsole.log(str1.indexOf('a', 2)); // 3\n\tconsole.log(str1.lastIndexOf('a', 1)); // 1\n\n> 注：调用此方法，要查询的指定字符若存在于目标字符串中，则返回对应的下标，若不存在，则返回 -1 ，可根据此特性，来判断某一字符串中是否含有某一指定字符，如：   \n\n\t// 判断str1中是否含有字符'a'\n\tvar str1 = 'Java Script';\n\tfunction checkStr (targetStr) {\n\t  if (str1.indexOf(targetStr) > -1) {\n\t    alert('str1中含有字符'+targetStr);\n\t  } else {\n\t    alert('str1中不含有字符'+targetStr);\n\t  }\n\t}\n\t// 检查是否含有字符'a'\n\tcheckStr('a');\n\t// 检查是否含有字符'abc'\n\tcheckStr('abc');\n\n### 9. 面试题\n\t\n\tfunction getSuffix(file){\n      return file.slice(file.lastIndexOf(\".\") + 1,file.length); \n\t}\n\n\tconsole.log(getSuffix('test.min.js')); // js","slug":"2017-08-05-javascript基础之字符串操作","published":1,"updated":"2019-03-20T14:35:09.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7gus000ngp9ajrf4jjfi","content":"<h2 id=\"js对字符串的操作\"><a href=\"#js对字符串的操作\" class=\"headerlink\" title=\"js对字符串的操作\"></a>js对字符串的操作</h2><h3 id=\"1-将其它类型的数据转换为字符串\"><a href=\"#1-将其它类型的数据转换为字符串\" class=\"headerlink\" title=\"1. 将其它类型的数据转换为字符串\"></a>1. 将其它类型的数据转换为字符串</h3><blockquote>\n<p>语法：<br>可以调用 stringObj.toString() 方法，String(stringObj) 方法，或者饮食转化 “” + stringObj;<br>使用如下：   </p>\n</blockquote>\n<a id=\"more\"></a>\n<pre><code>var num = 19;\nvar numStr0 = num.toString();\nvar numStr1 = String(num);\nvar numStr2 = &apos;&apos; + num;\n</code></pre><h3 id=\"2-获取字符串的长度\"><a href=\"#2-获取字符串的长度\" class=\"headerlink\" title=\"2. 获取字符串的长度\"></a>2. 获取字符串的长度</h3><blockquote>\n<p>语法：<br>stringObj.length</p>\n</blockquote>\n<pre><code>var str = &apos;javaScript&apos;;\nconsole.log(str.length); // 10\n</code></pre><h3 id=\"3-字符串替换\"><a href=\"#3-字符串替换\" class=\"headerlink\" title=\"3. 字符串替换\"></a>3. 字符串替换</h3><blockquote>\n<p>语法：<br>stringObj.replace(rgExp, replaceText)，返回替换后的字符串，原字符串不变，参数说明如下：<br>reExp可以是正则表达式对象(RegExp)，也可以是字符串(string)，replaceText是替代的查找到的字符串；<br>使用如下：  </p>\n</blockquote>\n<pre><code>var str = &apos;php是世界上最好的语言&apos;;\nvar strRes = str.replace(&apos;php&apos;, &apos;javascript才&apos;);\nconsole.log(str + &apos;?开玩笑，&apos; + strRes);\n</code></pre><h3 id=\"4-查找给定位置的字符或其字符编码值\"><a href=\"#4-查找给定位置的字符或其字符编码值\" class=\"headerlink\" title=\"4. 查找给定位置的字符或其字符编码值\"></a>4. 查找给定位置的字符或其字符编码值</h3><blockquote>\n<p>语法：  </p>\n<ol>\n<li>查找指定位置的字符： stringObj.charAt(index)，返回查找到的字符，不影响原数组；<br>参数解析，index为要查找的指定位置字符的下标索引。</li>\n<li>查找指定位置字符的字符编码值，stringObj.charCodeAt(index)  </li>\n</ol>\n</blockquote>\n<pre><code>// 获取指定位置的字符\nvar str = &apos;javaScript&apos;;\nvar strCharAt = str.charAt(6);\nvar strCharCodeAt = str.charCodeAt(6);\nconsole.log(str+&quot;的第7位字符是:&quot;+strCharAt+&quot;,其字符编码值为：&quot;+strCharCodeAt); // javaScript的第7位字符是:r,其字符编码值为：114\n</code></pre><h3 id=\"5-字符串连接\"><a href=\"#5-字符串连接\" class=\"headerlink\" title=\"5. 字符串连接\"></a>5. 字符串连接</h3><blockquote>\n<p>语法：  </p>\n<ol>\n<li>直接使用 + ，  </li>\n<li>stringObj.concat(stringObj2)，返回拼接后的字符串，对原字符串无影响   </li>\n</ol>\n</blockquote>\n<pre><code>var firstStr = &apos;java&apos;;\nvar lastStr = &apos;script&apos;;\nvar strRes = firstStr.concat(lastStr);\nconsole.log(strRes+&quot;是由字符串&quot;+firstStr+&apos;和&apos;+lastStr+&apos;拼接而成的&apos;); // javascript是由字符串java和script拼接而成的\n</code></pre><h3 id=\"6-字符串的切割和提取\"><a href=\"#6-字符串的切割和提取\" class=\"headerlink\" title=\"6. 字符串的切割和提取\"></a>6. 字符串的切割和提取</h3><blockquote>\n<p>语法：  </p>\n<ol>\n<li>stringObj.slice(start, end)，返回截取得到的字符串，不影响原字符串，  </li>\n<li>stringObj.substring(start, end)，返回截取得到的字符串，不影响原字符串，  </li>\n<li>stringObj.substr(start, end)，返回截取得到的字符串，不影响原字符串。<br>参数解析：  </li>\n<li>对于slice()和substring()方法而言：<br>start： 必选，非负，指定开始位置的下标，<br>end: 可选，非负，指定结束位置的下标，不传，默认到字符串末尾，<br>返回的子串包括 start 处的字符，但不包括 stop 处的字符。  </li>\n<li>对于substr()方法而言：<br>start: 必选，非负，指定开始位置的下标，<br>end: 可选，非负，指定截取的最大长度，不传，默认到字符串结尾。  </li>\n<li>对于三种方法而言，参数end如果是一个大于字符串长度的值，则截取到字符串结尾终止</li>\n</ol>\n</blockquote>\n<pre><code>var str = &apos;javaScript&apos;;\nvar sliceStr0 = str.slice(1, 5);\nvar sliceStr1 = str.slice(1, 15);\nvar substringStr0 = str.substring(1, 5);\nvar substringStr1 = str.substring(1, 15);\nvar substrStr0 = str.substr(1, 5);\nvar substrStr1 = str.substr(1, 15);\nconsole.log(str); // javascript\nconsole.log(sliceStr0); // avaS\nconsole.log(sliceStr1); // avaScript\nconsole.log(substringStr0); // avaS\nconsole.log(substringStr1); // avaScript\nconsole.log(substrStr0); // avaSc\nconsole.log(substrStr1); // avaScript\n</code></pre><h3 id=\"8-字符串大小写转换\"><a href=\"#8-字符串大小写转换\" class=\"headerlink\" title=\"8. 字符串大小写转换\"></a>8. 字符串大小写转换</h3><blockquote>\n<p>语法：<br>stringObj.toLowerCase(): 将字符串转换为小写，返回被转换之后的字符串，不影响原字符串。<br>stringObj.toLocaleLowerCase(): 将字符串转换为小写，返回被转换之后的字符串，不影响原字符串。<br>stringObj.toUpperCase(): 将字符串转换为大写，返回被转换之后的字符串，不影响原字符串。<br>stringObj.toLocaleUpperCase(): 将字符串转换为大写，返回被转换之后的字符串，不影响原字符串。  </p>\n</blockquote>\n<pre><code>var str = &apos;JavaScript&apos;;\nvar lowerCase = str.toLowerCase();\nvar localLowerCase = str.toLocaleLowerCase();\nconsole.log(str+&quot;转化为小写为：&quot;+lowerCase); // JavaScript转化为小写为：javascript\nconsole.log(str+&quot;转化为小写为：&quot;+localLowerCase); // JavaScript转化为小写为：javascript\nvar upperCase = str.toUpperCase();\nvar localUpperCase = str.toLocaleUpperCase();\nconsole.log(str+&quot;转化为大写为：&quot;+upperCase); // JavaScript转化为大写为：JAVASCRIPT\nconsole.log(str+&quot;转化为大写为：&quot;+localUpperCase); // JavaScript转化为大写为：JAVASCRIPT\n</code></pre><h3 id=\"7-把字符串分割成数组-——-split\"><a href=\"#7-把字符串分割成数组-——-split\" class=\"headerlink\" title=\"7. 把字符串分割成数组 —— split()\"></a>7. 把字符串分割成数组 —— split()</h3><blockquote>\n<p>用法： stringObject.split(separator,howmany)<br>separator：必选，类型为字符串或者数组，指定要切割的地方。(返回数组含用来指定切割的字符)<br>howmany：可选择，返回数组的最大长度。</p>\n</blockquote>\n<pre><code>var str1 = &apos;JavaScript&apos;;\nconsole.log(str1.split(&apos;&apos;)); // [&quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;S&quot;, &quot;c&quot;, &quot;r&quot;, &quot;i&quot;, &quot;p&quot;, &quot;t&quot;]\nconsole.log(str1.split(&apos;&apos;, 6)); // [&quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;S&quot;, &quot;c&quot;]\nconsole.log(str1.split(&apos;&apos;, 20)); // [&quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;S&quot;, &quot;c&quot;, &quot;r&quot;, &quot;i&quot;, &quot;p&quot;, &quot;t&quot;]\n\nvar str2 = &apos;Java Script&apos;;\nconsole.log(str2.split(/\\s+/)); // [&quot;Java&quot;, &quot;Script&quot;]\n</code></pre><h3 id=\"8-查询字符串\"><a href=\"#8-查询字符串\" class=\"headerlink\" title=\"8. 查询字符串\"></a>8. 查询字符串</h3><blockquote>\n<p>语法：<br>stringOb.indexOf(searchvalue,fromindex),从字符串的开头开始查找，找到返回对应的下标，找不到返回-1，此方法对大小写敏感。<br>stringOb.lastIndexOf(searchvalue,fromindex),从字符串的末尾开始查找，找到返回对应的下标，找不到返回-1，此方法对大小写敏感。<br>参数解析：<br>相同点：<br>searchvalue：必须，规定检索的字符串值<br>不同点：<br>indexOf()方法中参数fromindex：可选，开始检索的地方，从哪开始查找，合法取值：0—stringObject.length，当然不合法取个负值也是不会报错的只是会被视作0或者说空<br>lastIndexOf()方法中的参数fromindex：可选，建议不填，奇妙的第二个参数，能不用就不用</p>\n</blockquote>\n<pre><code>var str1 = &apos;Java Script&apos;;\nconsole.log(str1.indexOf(&apos;a&apos;)); // 1\nconsole.log(str1.lastIndexOf(&apos;a&apos;)); // 3\nconsole.log(str1.indexOf(&apos;a&apos;, 1)); // 1\nconsole.log(str1.lastIndexOf(&apos;a&apos;, 1)); // 1\nconsole.log(str1.indexOf(&apos;a&apos;, 2)); // 3\nconsole.log(str1.lastIndexOf(&apos;a&apos;, 1)); // 1\n</code></pre><blockquote>\n<p>注：调用此方法，要查询的指定字符若存在于目标字符串中，则返回对应的下标，若不存在，则返回 -1 ，可根据此特性，来判断某一字符串中是否含有某一指定字符，如：   </p>\n</blockquote>\n<pre><code>// 判断str1中是否含有字符&apos;a&apos;\nvar str1 = &apos;Java Script&apos;;\nfunction checkStr (targetStr) {\n  if (str1.indexOf(targetStr) &gt; -1) {\n    alert(&apos;str1中含有字符&apos;+targetStr);\n  } else {\n    alert(&apos;str1中不含有字符&apos;+targetStr);\n  }\n}\n// 检查是否含有字符&apos;a&apos;\ncheckStr(&apos;a&apos;);\n// 检查是否含有字符&apos;abc&apos;\ncheckStr(&apos;abc&apos;);\n</code></pre><h3 id=\"9-面试题\"><a href=\"#9-面试题\" class=\"headerlink\" title=\"9. 面试题\"></a>9. 面试题</h3><pre><code>function getSuffix(file){\n  return file.slice(file.lastIndexOf(&quot;.&quot;) + 1,file.length); \n}\n\nconsole.log(getSuffix(&apos;test.min.js&apos;)); // js\n</code></pre>","site":{"data":{}},"excerpt":"<h2 id=\"js对字符串的操作\"><a href=\"#js对字符串的操作\" class=\"headerlink\" title=\"js对字符串的操作\"></a>js对字符串的操作</h2><h3 id=\"1-将其它类型的数据转换为字符串\"><a href=\"#1-将其它类型的数据转换为字符串\" class=\"headerlink\" title=\"1. 将其它类型的数据转换为字符串\"></a>1. 将其它类型的数据转换为字符串</h3><blockquote>\n<p>语法：<br>可以调用 stringObj.toString() 方法，String(stringObj) 方法，或者饮食转化 “” + stringObj;<br>使用如下：   </p>\n</blockquote>","more":"<pre><code>var num = 19;\nvar numStr0 = num.toString();\nvar numStr1 = String(num);\nvar numStr2 = &apos;&apos; + num;\n</code></pre><h3 id=\"2-获取字符串的长度\"><a href=\"#2-获取字符串的长度\" class=\"headerlink\" title=\"2. 获取字符串的长度\"></a>2. 获取字符串的长度</h3><blockquote>\n<p>语法：<br>stringObj.length</p>\n</blockquote>\n<pre><code>var str = &apos;javaScript&apos;;\nconsole.log(str.length); // 10\n</code></pre><h3 id=\"3-字符串替换\"><a href=\"#3-字符串替换\" class=\"headerlink\" title=\"3. 字符串替换\"></a>3. 字符串替换</h3><blockquote>\n<p>语法：<br>stringObj.replace(rgExp, replaceText)，返回替换后的字符串，原字符串不变，参数说明如下：<br>reExp可以是正则表达式对象(RegExp)，也可以是字符串(string)，replaceText是替代的查找到的字符串；<br>使用如下：  </p>\n</blockquote>\n<pre><code>var str = &apos;php是世界上最好的语言&apos;;\nvar strRes = str.replace(&apos;php&apos;, &apos;javascript才&apos;);\nconsole.log(str + &apos;?开玩笑，&apos; + strRes);\n</code></pre><h3 id=\"4-查找给定位置的字符或其字符编码值\"><a href=\"#4-查找给定位置的字符或其字符编码值\" class=\"headerlink\" title=\"4. 查找给定位置的字符或其字符编码值\"></a>4. 查找给定位置的字符或其字符编码值</h3><blockquote>\n<p>语法：  </p>\n<ol>\n<li>查找指定位置的字符： stringObj.charAt(index)，返回查找到的字符，不影响原数组；<br>参数解析，index为要查找的指定位置字符的下标索引。</li>\n<li>查找指定位置字符的字符编码值，stringObj.charCodeAt(index)  </li>\n</ol>\n</blockquote>\n<pre><code>// 获取指定位置的字符\nvar str = &apos;javaScript&apos;;\nvar strCharAt = str.charAt(6);\nvar strCharCodeAt = str.charCodeAt(6);\nconsole.log(str+&quot;的第7位字符是:&quot;+strCharAt+&quot;,其字符编码值为：&quot;+strCharCodeAt); // javaScript的第7位字符是:r,其字符编码值为：114\n</code></pre><h3 id=\"5-字符串连接\"><a href=\"#5-字符串连接\" class=\"headerlink\" title=\"5. 字符串连接\"></a>5. 字符串连接</h3><blockquote>\n<p>语法：  </p>\n<ol>\n<li>直接使用 + ，  </li>\n<li>stringObj.concat(stringObj2)，返回拼接后的字符串，对原字符串无影响   </li>\n</ol>\n</blockquote>\n<pre><code>var firstStr = &apos;java&apos;;\nvar lastStr = &apos;script&apos;;\nvar strRes = firstStr.concat(lastStr);\nconsole.log(strRes+&quot;是由字符串&quot;+firstStr+&apos;和&apos;+lastStr+&apos;拼接而成的&apos;); // javascript是由字符串java和script拼接而成的\n</code></pre><h3 id=\"6-字符串的切割和提取\"><a href=\"#6-字符串的切割和提取\" class=\"headerlink\" title=\"6. 字符串的切割和提取\"></a>6. 字符串的切割和提取</h3><blockquote>\n<p>语法：  </p>\n<ol>\n<li>stringObj.slice(start, end)，返回截取得到的字符串，不影响原字符串，  </li>\n<li>stringObj.substring(start, end)，返回截取得到的字符串，不影响原字符串，  </li>\n<li>stringObj.substr(start, end)，返回截取得到的字符串，不影响原字符串。<br>参数解析：  </li>\n<li>对于slice()和substring()方法而言：<br>start： 必选，非负，指定开始位置的下标，<br>end: 可选，非负，指定结束位置的下标，不传，默认到字符串末尾，<br>返回的子串包括 start 处的字符，但不包括 stop 处的字符。  </li>\n<li>对于substr()方法而言：<br>start: 必选，非负，指定开始位置的下标，<br>end: 可选，非负，指定截取的最大长度，不传，默认到字符串结尾。  </li>\n<li>对于三种方法而言，参数end如果是一个大于字符串长度的值，则截取到字符串结尾终止</li>\n</ol>\n</blockquote>\n<pre><code>var str = &apos;javaScript&apos;;\nvar sliceStr0 = str.slice(1, 5);\nvar sliceStr1 = str.slice(1, 15);\nvar substringStr0 = str.substring(1, 5);\nvar substringStr1 = str.substring(1, 15);\nvar substrStr0 = str.substr(1, 5);\nvar substrStr1 = str.substr(1, 15);\nconsole.log(str); // javascript\nconsole.log(sliceStr0); // avaS\nconsole.log(sliceStr1); // avaScript\nconsole.log(substringStr0); // avaS\nconsole.log(substringStr1); // avaScript\nconsole.log(substrStr0); // avaSc\nconsole.log(substrStr1); // avaScript\n</code></pre><h3 id=\"8-字符串大小写转换\"><a href=\"#8-字符串大小写转换\" class=\"headerlink\" title=\"8. 字符串大小写转换\"></a>8. 字符串大小写转换</h3><blockquote>\n<p>语法：<br>stringObj.toLowerCase(): 将字符串转换为小写，返回被转换之后的字符串，不影响原字符串。<br>stringObj.toLocaleLowerCase(): 将字符串转换为小写，返回被转换之后的字符串，不影响原字符串。<br>stringObj.toUpperCase(): 将字符串转换为大写，返回被转换之后的字符串，不影响原字符串。<br>stringObj.toLocaleUpperCase(): 将字符串转换为大写，返回被转换之后的字符串，不影响原字符串。  </p>\n</blockquote>\n<pre><code>var str = &apos;JavaScript&apos;;\nvar lowerCase = str.toLowerCase();\nvar localLowerCase = str.toLocaleLowerCase();\nconsole.log(str+&quot;转化为小写为：&quot;+lowerCase); // JavaScript转化为小写为：javascript\nconsole.log(str+&quot;转化为小写为：&quot;+localLowerCase); // JavaScript转化为小写为：javascript\nvar upperCase = str.toUpperCase();\nvar localUpperCase = str.toLocaleUpperCase();\nconsole.log(str+&quot;转化为大写为：&quot;+upperCase); // JavaScript转化为大写为：JAVASCRIPT\nconsole.log(str+&quot;转化为大写为：&quot;+localUpperCase); // JavaScript转化为大写为：JAVASCRIPT\n</code></pre><h3 id=\"7-把字符串分割成数组-——-split\"><a href=\"#7-把字符串分割成数组-——-split\" class=\"headerlink\" title=\"7. 把字符串分割成数组 —— split()\"></a>7. 把字符串分割成数组 —— split()</h3><blockquote>\n<p>用法： stringObject.split(separator,howmany)<br>separator：必选，类型为字符串或者数组，指定要切割的地方。(返回数组含用来指定切割的字符)<br>howmany：可选择，返回数组的最大长度。</p>\n</blockquote>\n<pre><code>var str1 = &apos;JavaScript&apos;;\nconsole.log(str1.split(&apos;&apos;)); // [&quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;S&quot;, &quot;c&quot;, &quot;r&quot;, &quot;i&quot;, &quot;p&quot;, &quot;t&quot;]\nconsole.log(str1.split(&apos;&apos;, 6)); // [&quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;S&quot;, &quot;c&quot;]\nconsole.log(str1.split(&apos;&apos;, 20)); // [&quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;S&quot;, &quot;c&quot;, &quot;r&quot;, &quot;i&quot;, &quot;p&quot;, &quot;t&quot;]\n\nvar str2 = &apos;Java Script&apos;;\nconsole.log(str2.split(/\\s+/)); // [&quot;Java&quot;, &quot;Script&quot;]\n</code></pre><h3 id=\"8-查询字符串\"><a href=\"#8-查询字符串\" class=\"headerlink\" title=\"8. 查询字符串\"></a>8. 查询字符串</h3><blockquote>\n<p>语法：<br>stringOb.indexOf(searchvalue,fromindex),从字符串的开头开始查找，找到返回对应的下标，找不到返回-1，此方法对大小写敏感。<br>stringOb.lastIndexOf(searchvalue,fromindex),从字符串的末尾开始查找，找到返回对应的下标，找不到返回-1，此方法对大小写敏感。<br>参数解析：<br>相同点：<br>searchvalue：必须，规定检索的字符串值<br>不同点：<br>indexOf()方法中参数fromindex：可选，开始检索的地方，从哪开始查找，合法取值：0—stringObject.length，当然不合法取个负值也是不会报错的只是会被视作0或者说空<br>lastIndexOf()方法中的参数fromindex：可选，建议不填，奇妙的第二个参数，能不用就不用</p>\n</blockquote>\n<pre><code>var str1 = &apos;Java Script&apos;;\nconsole.log(str1.indexOf(&apos;a&apos;)); // 1\nconsole.log(str1.lastIndexOf(&apos;a&apos;)); // 3\nconsole.log(str1.indexOf(&apos;a&apos;, 1)); // 1\nconsole.log(str1.lastIndexOf(&apos;a&apos;, 1)); // 1\nconsole.log(str1.indexOf(&apos;a&apos;, 2)); // 3\nconsole.log(str1.lastIndexOf(&apos;a&apos;, 1)); // 1\n</code></pre><blockquote>\n<p>注：调用此方法，要查询的指定字符若存在于目标字符串中，则返回对应的下标，若不存在，则返回 -1 ，可根据此特性，来判断某一字符串中是否含有某一指定字符，如：   </p>\n</blockquote>\n<pre><code>// 判断str1中是否含有字符&apos;a&apos;\nvar str1 = &apos;Java Script&apos;;\nfunction checkStr (targetStr) {\n  if (str1.indexOf(targetStr) &gt; -1) {\n    alert(&apos;str1中含有字符&apos;+targetStr);\n  } else {\n    alert(&apos;str1中不含有字符&apos;+targetStr);\n  }\n}\n// 检查是否含有字符&apos;a&apos;\ncheckStr(&apos;a&apos;);\n// 检查是否含有字符&apos;abc&apos;\ncheckStr(&apos;abc&apos;);\n</code></pre><h3 id=\"9-面试题\"><a href=\"#9-面试题\" class=\"headerlink\" title=\"9. 面试题\"></a>9. 面试题</h3><pre><code>function getSuffix(file){\n  return file.slice(file.lastIndexOf(&quot;.&quot;) + 1,file.length); \n}\n\nconsole.log(getSuffix(&apos;test.min.js&apos;)); // js\n</code></pre>"},{"title":"java基本语法","date":"2019-06-15T14:33:15.000Z","_content":"## 1. java基本语法\n### 1. 标识符规则：\n1. 由26个字母大小写，0-9，和 _ 和 $（禁止使用）；\n2. 数字不可以开头；\n3. 不可以使用关键字和保留字；\n4. 严格区分大小写，长度最大65535；\n5. 不能使用空格。\n\n### 2. 命名规范：\n1. 包名： 全部小写；\n2. 类名： 首字母大写，后面的每个单词的首字母也大写，如 MyClassName（驼峰命名法）；\n3. 变量名和方法名：  首字母小写，后面的每个单词首字母大写；\n4. 常量名：  全部大写，单词间用 _ 隔开。\n\n### 3. 变量\n> 作用：用于保存数据。\n\n#### 3.1 变量的概念：\n1. 内存中的存储区域；\n2. 该区域由自己的名称（变量名）和类型（数据类型）；\n3. java中每个变量必须先声明，后使用；\n4. 该区域的数据可以在同一类型范围内不断变化；\n5. 变量的声明： 数据类型 变量名。\n\n#### 3.2 使用变量需注意：\n1. 变量的作用范围，一对 {} 之间的区域；","source":"_posts/java基本语法-md.md","raw":"---\ntitle: java基本语法\ndate: 2019-06-15 22:33:15\ntags: java\n---\n## 1. java基本语法\n### 1. 标识符规则：\n1. 由26个字母大小写，0-9，和 _ 和 $（禁止使用）；\n2. 数字不可以开头；\n3. 不可以使用关键字和保留字；\n4. 严格区分大小写，长度最大65535；\n5. 不能使用空格。\n\n### 2. 命名规范：\n1. 包名： 全部小写；\n2. 类名： 首字母大写，后面的每个单词的首字母也大写，如 MyClassName（驼峰命名法）；\n3. 变量名和方法名：  首字母小写，后面的每个单词首字母大写；\n4. 常量名：  全部大写，单词间用 _ 隔开。\n\n### 3. 变量\n> 作用：用于保存数据。\n\n#### 3.1 变量的概念：\n1. 内存中的存储区域；\n2. 该区域由自己的名称（变量名）和类型（数据类型）；\n3. java中每个变量必须先声明，后使用；\n4. 该区域的数据可以在同一类型范围内不断变化；\n5. 变量的声明： 数据类型 变量名。\n\n#### 3.2 使用变量需注意：\n1. 变量的作用范围，一对 {} 之间的区域；","slug":"java基本语法-md","published":1,"updated":"2019-06-15T15:16:51.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7guu000qgp9aowmunc77","content":"<h2 id=\"1-java基本语法\"><a href=\"#1-java基本语法\" class=\"headerlink\" title=\"1. java基本语法\"></a>1. java基本语法</h2><h3 id=\"1-标识符规则：\"><a href=\"#1-标识符规则：\" class=\"headerlink\" title=\"1. 标识符规则：\"></a>1. 标识符规则：</h3><ol>\n<li>由26个字母大小写，0-9，和 _ 和 $（禁止使用）；</li>\n<li>数字不可以开头；</li>\n<li>不可以使用关键字和保留字；</li>\n<li>严格区分大小写，长度最大65535；</li>\n<li>不能使用空格。</li>\n</ol>\n<h3 id=\"2-命名规范：\"><a href=\"#2-命名规范：\" class=\"headerlink\" title=\"2. 命名规范：\"></a>2. 命名规范：</h3><ol>\n<li>包名： 全部小写；</li>\n<li>类名： 首字母大写，后面的每个单词的首字母也大写，如 MyClassName（驼峰命名法）；</li>\n<li>变量名和方法名：  首字母小写，后面的每个单词首字母大写；</li>\n<li>常量名：  全部大写，单词间用 _ 隔开。</li>\n</ol>\n<h3 id=\"3-变量\"><a href=\"#3-变量\" class=\"headerlink\" title=\"3. 变量\"></a>3. 变量</h3><blockquote>\n<p>作用：用于保存数据。</p>\n</blockquote>\n<h4 id=\"3-1-变量的概念：\"><a href=\"#3-1-变量的概念：\" class=\"headerlink\" title=\"3.1 变量的概念：\"></a>3.1 变量的概念：</h4><ol>\n<li>内存中的存储区域；</li>\n<li>该区域由自己的名称（变量名）和类型（数据类型）；</li>\n<li>java中每个变量必须先声明，后使用；</li>\n<li>该区域的数据可以在同一类型范围内不断变化；</li>\n<li>变量的声明： 数据类型 变量名。</li>\n</ol>\n<h4 id=\"3-2-使用变量需注意：\"><a href=\"#3-2-使用变量需注意：\" class=\"headerlink\" title=\"3.2 使用变量需注意：\"></a>3.2 使用变量需注意：</h4><ol>\n<li>变量的作用范围，一对 {} 之间的区域；</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-java基本语法\"><a href=\"#1-java基本语法\" class=\"headerlink\" title=\"1. java基本语法\"></a>1. java基本语法</h2><h3 id=\"1-标识符规则：\"><a href=\"#1-标识符规则：\" class=\"headerlink\" title=\"1. 标识符规则：\"></a>1. 标识符规则：</h3><ol>\n<li>由26个字母大小写，0-9，和 _ 和 $（禁止使用）；</li>\n<li>数字不可以开头；</li>\n<li>不可以使用关键字和保留字；</li>\n<li>严格区分大小写，长度最大65535；</li>\n<li>不能使用空格。</li>\n</ol>\n<h3 id=\"2-命名规范：\"><a href=\"#2-命名规范：\" class=\"headerlink\" title=\"2. 命名规范：\"></a>2. 命名规范：</h3><ol>\n<li>包名： 全部小写；</li>\n<li>类名： 首字母大写，后面的每个单词的首字母也大写，如 MyClassName（驼峰命名法）；</li>\n<li>变量名和方法名：  首字母小写，后面的每个单词首字母大写；</li>\n<li>常量名：  全部大写，单词间用 _ 隔开。</li>\n</ol>\n<h3 id=\"3-变量\"><a href=\"#3-变量\" class=\"headerlink\" title=\"3. 变量\"></a>3. 变量</h3><blockquote>\n<p>作用：用于保存数据。</p>\n</blockquote>\n<h4 id=\"3-1-变量的概念：\"><a href=\"#3-1-变量的概念：\" class=\"headerlink\" title=\"3.1 变量的概念：\"></a>3.1 变量的概念：</h4><ol>\n<li>内存中的存储区域；</li>\n<li>该区域由自己的名称（变量名）和类型（数据类型）；</li>\n<li>java中每个变量必须先声明，后使用；</li>\n<li>该区域的数据可以在同一类型范围内不断变化；</li>\n<li>变量的声明： 数据类型 变量名。</li>\n</ol>\n<h4 id=\"3-2-使用变量需注意：\"><a href=\"#3-2-使用变量需注意：\" class=\"headerlink\" title=\"3.2 使用变量需注意：\"></a>3.2 使用变量需注意：</h4><ol>\n<li>变量的作用范围，一对 {} 之间的区域；</li>\n</ol>\n"},{"title":"vue-node.md","date":"2019-03-24T14:43:48.000Z","_content":"\n","source":"_posts/vue-node-md.md","raw":"---\ntitle: vue-node.md\ndate: 2019-03-24 22:43:48\ncategories: vue\ntags: [vue-node, get, post, get]\n---\n\n","slug":"vue-node-md","published":1,"updated":"2019-03-24T14:47:52.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7guv000sgp9a7a13sizm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java基础入门","date":"2019-06-10T14:03:36.000Z","_content":"\n### 1. JAVA基础介绍\n#### 1.1 java面向对象编程\n> 面向对象编程的三大特性 \n> > 封装：  \n> > 继承：  \n> > 多态：  \n> > （抽象）：\n\n+ java程序要素介绍：\n\t1. java源文件以“.java”为扩展名。源文件的基本组成部分是类（class），如本类中的 PersonInfo 类\n\t2. 一个源文件中最多只能有一个 public 类。其它类的个数不限，如果源文件包含一个 public 类，则文件名必须按该雷鸣命名。\n\t<!--more-->\n\t3. Java应用程序的执行文件入口是 main() 方法。它有固定的书写格式：**public static void main(String[] args){...}**\n\t4. Java语言严格区分大小写。\n\t5. Java方法由一条条语句构成，每个语句以“;”结束。\n\t6. 打括号是成对出现的，缺一不可。\n\t\t\t\n\t\t\t/**\n\t\t\t *  public: 公共的，公开的\n\t\t\t *  class: 类的定义\n\t\t\t *  PersonInfo: 类名\n\t\t\t *  类是java程序最基本的单位\n\t\t\t *  类 = 类头（类签名） + 类体\n\t\t\t *  public class PersonInfo: 类名\n\t\t\t *  { }: 类体，类后面的一对 {} 及其中的内容\n\t\t\t *  main: 主方法，程序的入口方法\n\t\t\t *  主类: 包含主方法的类就是主类\n\t\t\t*/\n\t\t\tpublic class PersonInfo {\n\t\t\t    /**\n\t\t\t     *  方法: 完成某种特定功能的单位\n\t\t\t     *  public static: 修饰符\n\t\t\t     *  void: 无返回值\n\t\t\t     *  main: 方法名\n\t\t\t     *  （String[] args）: 参数\n\t\t\t     *  方法名后面的一对 {} 及其中的内容称为方法体\n\t\t\t     *  方法 = 方法签名 + 方法体\n\t\t\t     */\n\t\t\t    public static void main (String[] args) {\n\t\t\t        /**\n\t\t\t         *  语句: java程序的最小执行单位，语句必须以分号 ; 结尾\n\t\t\t         */\n\t\t\t        System.out.println(\"姓名： 张三\");\n\t\t\t        System.out.println(\"性别： 男\");\n\t\t\t        System.out.println(\"籍贯： 河北\");\n\t\t\t        System.out.println(\"住址： 河北省保定市\");\n\t\t\t    }\n\t\t\t}\n\n+ 开发一个java程序的步骤：\n\n\t1. 在目录下创建一个文本文件，文件名是 公共类名.java，编辑这个文件\n\t2. 命令行下使用 javac 公共类名.java，编译源文件，产生多个.class文件，文件数量取决于 源文件中方法的个素\n\t3. 执行这个程序，java 主类名\n\n\t\n+ 执行过程：\n\t1. java 创建JVM\n\t2. \t由ClassLoader加载主类\n\t3. 执行主类中的主方法\n\t4. 主方法执行完毕后，销毁JVM.进程结束\n\t\n\t","source":"_posts/java基础-md.md","raw":"---\ntitle: java基础入门\ndate: 2019-06-10 22:03:36\ntags: JAVA\n---\n\n### 1. JAVA基础介绍\n#### 1.1 java面向对象编程\n> 面向对象编程的三大特性 \n> > 封装：  \n> > 继承：  \n> > 多态：  \n> > （抽象）：\n\n+ java程序要素介绍：\n\t1. java源文件以“.java”为扩展名。源文件的基本组成部分是类（class），如本类中的 PersonInfo 类\n\t2. 一个源文件中最多只能有一个 public 类。其它类的个数不限，如果源文件包含一个 public 类，则文件名必须按该雷鸣命名。\n\t<!--more-->\n\t3. Java应用程序的执行文件入口是 main() 方法。它有固定的书写格式：**public static void main(String[] args){...}**\n\t4. Java语言严格区分大小写。\n\t5. Java方法由一条条语句构成，每个语句以“;”结束。\n\t6. 打括号是成对出现的，缺一不可。\n\t\t\t\n\t\t\t/**\n\t\t\t *  public: 公共的，公开的\n\t\t\t *  class: 类的定义\n\t\t\t *  PersonInfo: 类名\n\t\t\t *  类是java程序最基本的单位\n\t\t\t *  类 = 类头（类签名） + 类体\n\t\t\t *  public class PersonInfo: 类名\n\t\t\t *  { }: 类体，类后面的一对 {} 及其中的内容\n\t\t\t *  main: 主方法，程序的入口方法\n\t\t\t *  主类: 包含主方法的类就是主类\n\t\t\t*/\n\t\t\tpublic class PersonInfo {\n\t\t\t    /**\n\t\t\t     *  方法: 完成某种特定功能的单位\n\t\t\t     *  public static: 修饰符\n\t\t\t     *  void: 无返回值\n\t\t\t     *  main: 方法名\n\t\t\t     *  （String[] args）: 参数\n\t\t\t     *  方法名后面的一对 {} 及其中的内容称为方法体\n\t\t\t     *  方法 = 方法签名 + 方法体\n\t\t\t     */\n\t\t\t    public static void main (String[] args) {\n\t\t\t        /**\n\t\t\t         *  语句: java程序的最小执行单位，语句必须以分号 ; 结尾\n\t\t\t         */\n\t\t\t        System.out.println(\"姓名： 张三\");\n\t\t\t        System.out.println(\"性别： 男\");\n\t\t\t        System.out.println(\"籍贯： 河北\");\n\t\t\t        System.out.println(\"住址： 河北省保定市\");\n\t\t\t    }\n\t\t\t}\n\n+ 开发一个java程序的步骤：\n\n\t1. 在目录下创建一个文本文件，文件名是 公共类名.java，编辑这个文件\n\t2. 命令行下使用 javac 公共类名.java，编译源文件，产生多个.class文件，文件数量取决于 源文件中方法的个素\n\t3. 执行这个程序，java 主类名\n\n\t\n+ 执行过程：\n\t1. java 创建JVM\n\t2. \t由ClassLoader加载主类\n\t3. 执行主类中的主方法\n\t4. 主方法执行完毕后，销毁JVM.进程结束\n\t\n\t","slug":"java基础-md","published":1,"updated":"2019-06-12T16:16:18.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7guw000vgp9amw2ltgdd","content":"<h3 id=\"1-JAVA基础介绍\"><a href=\"#1-JAVA基础介绍\" class=\"headerlink\" title=\"1. JAVA基础介绍\"></a>1. JAVA基础介绍</h3><h4 id=\"1-1-java面向对象编程\"><a href=\"#1-1-java面向对象编程\" class=\"headerlink\" title=\"1.1 java面向对象编程\"></a>1.1 java面向对象编程</h4><blockquote>\n<p>面向对象编程的三大特性 </p>\n<blockquote>\n<p>封装：<br>继承：<br>多态：<br>（抽象）：</p>\n</blockquote>\n</blockquote>\n<ul>\n<li><p>java程序要素介绍：</p>\n<ol>\n<li>java源文件以“.java”为扩展名。源文件的基本组成部分是类（class），如本类中的 PersonInfo 类</li>\n<li>一个源文件中最多只能有一个 public 类。其它类的个数不限，如果源文件包含一个 public 类，则文件名必须按该雷鸣命名。<a id=\"more\"></a></li>\n<li>Java应用程序的执行文件入口是 main() 方法。它有固定的书写格式：<strong>public static void main(String[] args){…}</strong></li>\n<li>Java语言严格区分大小写。</li>\n<li>Java方法由一条条语句构成，每个语句以“;”结束。</li>\n<li><p>打括号是成对出现的，缺一不可。</p>\n<pre><code>/**\n *  public: 公共的，公开的\n *  class: 类的定义\n *  PersonInfo: 类名\n *  类是java程序最基本的单位\n *  类 = 类头（类签名） + 类体\n *  public class PersonInfo: 类名\n *  { }: 类体，类后面的一对 {} 及其中的内容\n *  main: 主方法，程序的入口方法\n *  主类: 包含主方法的类就是主类\n*/\npublic class PersonInfo {\n    /**\n     *  方法: 完成某种特定功能的单位\n     *  public static: 修饰符\n     *  void: 无返回值\n     *  main: 方法名\n     *  （String[] args）: 参数\n     *  方法名后面的一对 {} 及其中的内容称为方法体\n     *  方法 = 方法签名 + 方法体\n     */\n    public static void main (String[] args) {\n        /**\n         *  语句: java程序的最小执行单位，语句必须以分号 ; 结尾\n         */\n        System.out.println(&quot;姓名： 张三&quot;);\n        System.out.println(&quot;性别： 男&quot;);\n        System.out.println(&quot;籍贯： 河北&quot;);\n        System.out.println(&quot;住址： 河北省保定市&quot;);\n    }\n}\n</code></pre></li>\n</ol>\n</li>\n<li><p>开发一个java程序的步骤：</p>\n<ol>\n<li>在目录下创建一个文本文件，文件名是 公共类名.java，编辑这个文件</li>\n<li>命令行下使用 javac 公共类名.java，编译源文件，产生多个.class文件，文件数量取决于 源文件中方法的个素</li>\n<li>执行这个程序，java 主类名</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>执行过程：<ol>\n<li>java 创建JVM</li>\n<li>由ClassLoader加载主类</li>\n<li>执行主类中的主方法</li>\n<li>主方法执行完毕后，销毁JVM.进程结束</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-JAVA基础介绍\"><a href=\"#1-JAVA基础介绍\" class=\"headerlink\" title=\"1. JAVA基础介绍\"></a>1. JAVA基础介绍</h3><h4 id=\"1-1-java面向对象编程\"><a href=\"#1-1-java面向对象编程\" class=\"headerlink\" title=\"1.1 java面向对象编程\"></a>1.1 java面向对象编程</h4><blockquote>\n<p>面向对象编程的三大特性 </p>\n<blockquote>\n<p>封装：<br>继承：<br>多态：<br>（抽象）：</p>\n</blockquote>\n</blockquote>\n<ul>\n<li><p>java程序要素介绍：</p>\n<ol>\n<li>java源文件以“.java”为扩展名。源文件的基本组成部分是类（class），如本类中的 PersonInfo 类</li>\n<li>一个源文件中最多只能有一个 public 类。其它类的个数不限，如果源文件包含一个 public 类，则文件名必须按该雷鸣命名。</li></ol></li></ul>","more":"</li>\n<li>Java应用程序的执行文件入口是 main() 方法。它有固定的书写格式：<strong>public static void main(String[] args){…}</strong></li>\n<li>Java语言严格区分大小写。</li>\n<li>Java方法由一条条语句构成，每个语句以“;”结束。</li>\n<li><p>打括号是成对出现的，缺一不可。</p>\n<pre><code>/**\n *  public: 公共的，公开的\n *  class: 类的定义\n *  PersonInfo: 类名\n *  类是java程序最基本的单位\n *  类 = 类头（类签名） + 类体\n *  public class PersonInfo: 类名\n *  { }: 类体，类后面的一对 {} 及其中的内容\n *  main: 主方法，程序的入口方法\n *  主类: 包含主方法的类就是主类\n*/\npublic class PersonInfo {\n    /**\n     *  方法: 完成某种特定功能的单位\n     *  public static: 修饰符\n     *  void: 无返回值\n     *  main: 方法名\n     *  （String[] args）: 参数\n     *  方法名后面的一对 {} 及其中的内容称为方法体\n     *  方法 = 方法签名 + 方法体\n     */\n    public static void main (String[] args) {\n        /**\n         *  语句: java程序的最小执行单位，语句必须以分号 ; 结尾\n         */\n        System.out.println(&quot;姓名： 张三&quot;);\n        System.out.println(&quot;性别： 男&quot;);\n        System.out.println(&quot;籍贯： 河北&quot;);\n        System.out.println(&quot;住址： 河北省保定市&quot;);\n    }\n}\n</code></pre></li>\n</ol>\n</li>\n<li><p>开发一个java程序的步骤：</p>\n<ol>\n<li>在目录下创建一个文本文件，文件名是 公共类名.java，编辑这个文件</li>\n<li>命令行下使用 javac 公共类名.java，编译源文件，产生多个.class文件，文件数量取决于 源文件中方法的个素</li>\n<li>执行这个程序，java 主类名</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>执行过程：<ol>\n<li>java 创建JVM</li>\n<li>由ClassLoader加载主类</li>\n<li>执行主类中的主方法</li>\n<li>主方法执行完毕后，销毁JVM.进程结束</li>\n</ol>\n</li>\n</ul>"},{"title":"vue学习笔记之vuex状态管理","date":"2019-03-28T13:43:36.000Z","_content":"\n#### vue学习笔记之vuex状态管理\n> vuex用于状态管理，使用如下  \n\n##### 1. 项目中引入vuex\n\n\tnpm i vuex -s\n\t\n* 1.1 下载安装完成，修改项目src/main.js，引入 `vuex`   \n\n\t\timoprt Vuex from 'vuex' // 引入Vuexœ\n\t\t\n\t\tVue.use(Vuex) // 声明使用Vuex","source":"_posts/vue学习笔记之vuex状态管理-md.md","raw":"---\ntitle: vue学习笔记之vuex状态管理\ndate: 2019-03-28 21:43:36\ncategories: vue\ntags: [vue, vuex]\n---\n\n#### vue学习笔记之vuex状态管理\n> vuex用于状态管理，使用如下  \n\n##### 1. 项目中引入vuex\n\n\tnpm i vuex -s\n\t\n* 1.1 下载安装完成，修改项目src/main.js，引入 `vuex`   \n\n\t\timoprt Vuex from 'vuex' // 引入Vuexœ\n\t\t\n\t\tVue.use(Vuex) // 声明使用Vuex","slug":"vue学习笔记之vuex状态管理-md","published":1,"updated":"2019-04-07T06:45:41.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7gux000ygp9aeutk0lp7","content":"<h4 id=\"vue学习笔记之vuex状态管理\"><a href=\"#vue学习笔记之vuex状态管理\" class=\"headerlink\" title=\"vue学习笔记之vuex状态管理\"></a>vue学习笔记之vuex状态管理</h4><blockquote>\n<p>vuex用于状态管理，使用如下  </p>\n</blockquote>\n<h5 id=\"1-项目中引入vuex\"><a href=\"#1-项目中引入vuex\" class=\"headerlink\" title=\"1. 项目中引入vuex\"></a>1. 项目中引入vuex</h5><pre><code>npm i vuex -s\n</code></pre><ul>\n<li><p>1.1 下载安装完成，修改项目src/main.js，引入 <code>vuex</code>   </p>\n<pre><code>imoprt Vuex from &apos;vuex&apos; // 引入Vuexœ\n\nVue.use(Vuex) // 声明使用Vuex\n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"vue学习笔记之vuex状态管理\"><a href=\"#vue学习笔记之vuex状态管理\" class=\"headerlink\" title=\"vue学习笔记之vuex状态管理\"></a>vue学习笔记之vuex状态管理</h4><blockquote>\n<p>vuex用于状态管理，使用如下  </p>\n</blockquote>\n<h5 id=\"1-项目中引入vuex\"><a href=\"#1-项目中引入vuex\" class=\"headerlink\" title=\"1. 项目中引入vuex\"></a>1. 项目中引入vuex</h5><pre><code>npm i vuex -s\n</code></pre><ul>\n<li><p>1.1 下载安装完成，修改项目src/main.js，引入 <code>vuex</code>   </p>\n<pre><code>imoprt Vuex from &apos;vuex&apos; // 引入Vuexœ\n\nVue.use(Vuex) // 声明使用Vuex\n</code></pre></li>\n</ul>\n"},{"title":"javascript基础","date":"2017-08-05T11:13:13.000Z","_content":"#### javascript基础\n##### 一. js对数组的操作\n###### 1. 数组的基本操作之 —— 增/删 (push(), pop(), unshift(), shift()) 操作\n* 增： push(): 向数组后添加内容，可接受任意数量的参数，会对原数组产生影响,返回修改后数组的长度  \n\n<!--more-->\n\n* 删： pop(): 删除数组最后一个元素，不接收参数，会对原数组产生影响，返回被删除的元素值，如果数组为空，则返回 undefined  \n\n* 增：unshift(): 向数组开头添加内容，可接受任意参数量的参数，会对原数组产生影响，返回修改后的数组的长度  \n\n* 删： shift(): 删除数组第一个元素，不接收参数，会对原数组产生影响，返回被删除的元素值，如果数组为空，则返回 undefined\n\n\t\tvar pushNumber = [1, 2, 3, 4, 5, 6];\n\t\tvar pushResult1 = pushNumber.push(7, '帅气');\n\t\tconsole.log(pushResult1); // 8\n\t\tconsole.log(pushNumber); // [1, 2, 3, 4, 5, 6, 7, '帅气']\n\t\tvar pushResult2 = pushNumber.unshift([7, '帅气']); // 注意添加的是一个数组，为一项\n\t\tconsole.log(pushResult2); // 9 \n\t\tconsole.log(pushNumber); // [[7, '帅气'], 1, 2, 3, 4, 5, 6, 7, '帅气'];\n\t\t\n\t\tvar popNumber = [1, 2, 3, 4, 5, 6];\n\t\tvar popResult1 = popNumber.pop();\n\t\tconsole.log(popResult1); // 6\n\t\tconsole.log(popNumber); // [1, 2, 3, 4, 5]\n\t\tvar popResult2 = popNumber.shift();\n\t\tconsole.log(popResult2); // 1\n\t\tconsole.log(popNumber); // [2, 3, 4, 5]\n\n###### 2. 数组的基本操作之 —— 通过指定索引对指定位置添加或者删除相应位置的元素(splice(), slice())\n> 说明：  \n> splice(): 从数组中添加或删除元素，返回被删除的项目，如果是添加，则返回一个空数组（注：会对原数组进行更改，获取的是新的数组），使用如下：  \n> a. 使用splice()方法添加元素：splice(index, 0, data1, data2, ...)，添加时，splice()方法返回一个空数组;  \n> 参数解析： index(插入的元素的起始位置，值为1，就是第一位开始，并非索引值), 0(删除的个数), data1/data2/...(添加的元素)；  \n\n\t// 向数组第一项之后插入新值\n\tvar spliceAddArr = [1, 2, 3, 4, 5, 6];\n\tvar spliceAddResult = spliceAddArr.splice(1, 0, 'a', 'b', 'c');\n\tconsole.log('spliceAddArr: ', spliceAddArr, '; spliceAddResult: ', spliceAddResult); // spliceAddArr: [1, \"a\", \"b\", \"c\", 2, 3, 4, 5, 6] ; spliceAddResult: []\n\n> b.1 使用splice()方法删除元素： splice(index, 3)，删除时，splice()方法返回被删除的元素的数组集合（注：会对原数组进行更改，原数组变更为删除之后的新数组）  \n> 参数解析： index(删除元素的起始位置，值为1，就是从第一位开始，并非索引值)，3(删除的个数)  \n> b.2 使用splice()方法删除元素的同时添加元素： splice(index, 3, data1, data2, ...)  \n> 参数解析： index(删除元素的起始位置，值为1，就是从第一位开始，并非索引值)，3(删除的个数)，data1/data2/...（添加的元素）；  \n\n\t// 使用splice()删除元素，返回被删除元素\n\tvar spliceDelArr = [1, 2, 3, 4, 5, 6];\n\tvar spliceDelResult = spliceDelArr.splice(1, 3);\n\tconsole.log('spliceDelArr: ', spliceDelArr, '; spliceDelResult: ', spliceDelResult); // spliceDelArr: [1, 5, 6] ; spliceDelResult: [2, 3, 4]\n\t\n\t// 使用splice()删除元素的同时添加元素\n\tvar spliceAddArr = [1, 2, 3, 4, 5, 6];\n\tvar spliceAddResult = spliceAddArr.splice(1, 3, 'a', 'b', 'c');\n\tconsole.log('spliceAddArr: ', spliceAddArr, '; spliceAddResult: ', spliceAddResult); // spliceDelArr: [1, \"a\", \"b\", \"c\", 5, 6] ; spliceDelResult: [2, 3, 4]\n\n> 注： 使用splice(),不管是用来添加还是删除元素，第一个参数都可以接受一个负数作为参数，与正数相比：  \n> 相同之处：  \n> 使用splice()添加元素，都是从起始位置的之后添加，即如果是正3，即从起始位置往后数3位添加，即从第三第四位中间添加元素，若为负数-3，即从后往前数三位的后一位，即从后往前数第三位到第四位中间添加，如果第一个参数，大于数组的实际长度，则从数组的末尾开始添加。  \n> 不同之处：  \n> 使用splice()删除元素，如果是正数3，如： splice(3, 3),即从开始位置往后数三位，从第四位开始删除三项，实际删除的是第四，第五，第六项，而当为负数-3时，如： splice(-3, 3)，即从后往前数三位，从倒数第三位开始删除，并不是倒数第四位，实际删除的项为倒数第三项，倒数第二项，倒数第一项三项。  \n> 如果删除的项数大于起始位置到数组的结束位置的项数，则默认到数组结束位置停止。  \n\t\n\t// splice()添加，index为正数时\n\tvar arr1 = [1, 2, 3, 4, 5];\n\tvar arrRes1 = arr1.splice(3, 0, 'a', 'b', 'c');\n\tconsole.log('arr1: ', arr1, '; arrRes1:', arrRes1); // arr1: [1, 2, 3, 'a', 'b', 'c', 4, 5] ； arrRes1： []\n\n\t// splice()添加，index为负数时\n\tvar arr2 = [1, 2, 3, 4, 5];\n\tvar arrRes2 = arr2.splice(-3, 0, 'a', 'b', 'c');\n\tconsole.log('arr2: ', arr2, '; arrRes2:', arrRes2); // arr2: [1, 2, \"a\", \"b\", \"c\", 3, 4, 5] ; arrRes2: []\n\n\t// splice()删除，index为正数时\n\tvar arr3 = [1, 2, 3, 4, 5, 6, 7];\n\tvar arrRes3 = arr3.splice(3, 3, 'a', 'b', 'c');\n\tconsole.log('arr3: ', arr3, '; arrRes3:', arrRes3); // arr3: [1, 2, 3, \"a\", \"b\", \"c\", 7] ； arrRes3： [4, 5, 6]\n\n\t// splice()删除，index为正数时\n\tvar arr4 = [1, 2, 3, 4, 5, 6, 7];\n\tvar arrRes4 = arr4.splice(-3, 3, 'a', 'b', 'c');\n\tconsole.log('arr4: ', arr4, '; arrRes4:', arrRes4); // arr3: [1, 2, 3, 4, \"a\", \"b\", \"c\"] ； arrRes3： [5, 6, 7]\n\n> slice()使用说明：用于截取数组，返回截取到的新的数组，此方法可以作用于字符串属性（注：不会影响原数组）;  \n> 此方法接受两个参数，slice(start, end)：  \n> start: 必传，截取开始位置的下标,  \n> end: 可传，截取结束的位置下标索引，不包括当前下标对应的元素，不传为数组结束。  \n\n\tvar sliceArr = [1, 2, 3, 4, 5, 6, 7];\n\tvar sliceRes0 = sliceArr.slice(2); // 实际截取的为：第三项到数组结束\n\tvar sliceRes1 = sliceArr.slice(2, 4); // 实际截取的为：第三项，第四项\n\tvar sliceRes2 = sliceArr.slice(-2); // 实际截取的为：第三项，第四项\n\tvar sliceRes3 = sliceArr.slice(-9); // 从后往前第九位，数组长度不够，从第一项开始截取到数组结束\n\tvar sliceRes4 = sliceArr.slice(-4, -2); // 实际截取的为从倒数第四项到倒数第二项：即为倒数第四项，倒数第五项两项\n\tvar sliceRes5 = sliceArr.slice(-4, -6); // 无匹配项，返回一个空数组\n\tvar sliceRes6 = sliceArr.slice(1, -2); // 从索引为1的位置开始，到倒数第二项，不包括倒数第二项\n\tvar sliceRes7 = sliceArr.slice(9); // 无匹配项，返回一个空数组\n\tconsole.log('sliceArr: ', sliceArr, '； sliceRes0: ', sliceRes0); // sliceArr1: [1, 2, 3, 4, 5, 6, 7] ; sliceRes0: [3, 4, 5, 6, 7]\n\tconsole.log('sliceRes1: ', sliceRes1); // sliceRes1: [3, 4]\n\tconsole.log('sliceRes2: ', sliceRes2); // sliceRes2: [6, 7]\n\tconsole.log('sliceRes3: ', sliceRes3); // sliceRes3: [1, 2, 3, 4, 5, 6, 7]\n\tconsole.log('sliceRes4: ', sliceRes4); // sliceRes4: [4, 5]\n\tconsole.log('sliceRes5: ', sliceRes5); // sliceRes5: []\n\tconsole.log('sliceRes6: ', sliceRes6); // sliceRes6: [2, 3, 4, 5]\n\tconsole.log('sliceRes7: ', sliceRes7); // sliceRes7: []\n\n###### 3. 数组的基本操作之 —— 对数组的每一项进行操作(map(), forEach())\n> 相同点:  \n> 1. 都是循环遍历数组中每一项  \n> 2. map和forEach每次执行匿名函数时都支持3个参数，参数分别是item(当前项)，index(索引值)，arr(原数组)  \n> 3. 匿名函数中的this都指向 window  \n> 4. 只能遍历数组  \n> 5. 都不会改变原数组  \n> \n> 区别：  \n> map方法：  \n> 1. map方法返回一个新的数组，数组中的元素为原始数组调用函数处理之后的值  \n> 2. map方法不会对空数组进行检测(即不会执行匿名函数，若为空数组，则调用map方法后也返回一个空数组)，map方法不会改变原始数组  \n> 3. 浏览器支持： chrome / Safari 1.5+ / opera / IE9+  \n> forEach方法：  \n> 1. forEach()方法用来调用数组的每个元素，将元素传给回调函数  \n> 2. forEach()方法不会对空数组进行检测，对于空数组是不会调用匿名函数的，注意，无论数组是否为空，调用forEach方法，返回值均为 undefined\n\n\t// map方法\n\tvar mapArr = [1, 2, 3, 4, 5];\n    var mapResult = mapArr.map(function(item, index, arr){\n      console.log(this); // window\n      console.log('原始数组mapArr: ', arr); // 原始数组mapArr: [1, 2, 3, 4, 5]\n      return item+1;\n    })\n    console.log('mapArr:', mapArr, '; mapResult: ', mapResult); // mapArr: [1, 2, 3, 4, 5] ; mapResult: [2, 3, 4, 5, 6]\n\n\t// 若为空数组，调用map方法，返回一个空数组，匿名函数不会执行\n\tvar empArr = [];\n\tvar mapEmpResult = empArr.map(function(){item, index, arr}{\n\t  // 空数组调用map方法，函数体不会执行\n      console.log(this);\n      console.log('原始数组mapArr: ', arr);\n      return item+1;\n\t})；\n\tconsole.log('empArr:', empArr, '; mapEmpResult: ', mapEmpResult); // empArr: [] ; mapEmpResult: []\n\n\t// forEach方法\n\tvar forEachArr = [1, 2, 3, 4, 5];\n\tvar forEachResult = forEachArr.forEach(function(item, index, arr){ // 调用forEach()方法，返回值均为 undefined\n\t  console.log(this); // window\n\t  console.log('原始数组forEachArr：', arr); // 原始数组forEachArr： [1, 2, 3, 4, 5]\n\t  return item+1;\n\t})\n    console.log('forEachArr:', forEachArr, '; forEachResult: ', forEachResult); // forEachArr: [1, 2, 3, 4, 5] ; forEachResult: undefined\n\n###### 4. 数组的基本操作之 —— 对数组的每一项进行操作（ filter() ）\n> 说明： 遍历每一项数组，接收一个匿名函数作为参数，函数接收三个参数，参数item(遍历得到的每一项数组值)，index（索引值），arr(数组本身)， 返回一个结果为true的item组成的新数组，不会影响原数组  \n\t\n\t// 需求：获取成绩合格的学生名单\n\tvar students = [\n      {name: '张三', age: 18, scroe: 89},\n      {name: '李四', age: 17, scroe: 71},\n      {name: '王五', age: 18, scroe: 56},\n      {name: '赵六', age: 19, scroe: 94},\n      {name: '小明', age: 18, scroe: 48},\n      {name: '小红', age: 19, scroe: 60},\n    ];\n\tvar studentsResult = students.filter(function(item){\n      if (item.scroe >= 60) {\n        return {\n          name: item.name,\n          age: item.age,\n          score: item.scroe\n        }\n      }\n    });\n    console.log(studentsResult); // 输出如下结果\n\t// [{name: \"张三\", age: 18, scroe: 89},\n\t// {name: \"李四\", age: 17, scroe: 71},\n\t// {name: \"赵六\", age: 19, scroe: 94},\n\t// {name: \"小红\", age: 19, scroe: 60}]\n\n###### 5. 数组的基本操作之 —— 对数组的迭代方法(every(), some())方法\n> 说明：every()和some()都是对js中数组的迭代方法，区别如下：  \n> 相同点：  \n> 1. 均接收一个匿名函数作为参数，函数接收三个参数，参数item(每一项),index（索引值），arr(原始数组)  \n> 2. 均对数组的每一项运行指定的匿名函数\n> \n> 不同点:  \n> every(): 对数组的每一项运行给定的函数，如果该函数每一项都返回 true, 则返回 true，若存在某项返回false，则终止函数迭代，返回false; (可用来判断是不是所有，类似于逻辑 &&)  \n> some(): 对数组的每一项运行给定的函数，如果该函数存在某一项返回 true, 函数终止，并返回 true; (可用来判断有没有，类似于逻辑 ||)\n\n\t// 判断数组是是否全为基数\n\t// 使用every()方法实现\n\tvar everyArr1 = [1, 3, 5, 7, 9];\n\tvar everyArr2 = [1, 3, 5, 6, 7, 9];\n\tvar everyResult1 = everyArr1.every(function(item, index, arr){\n      if (!(item % 2)) {\n        console.log('第'+(index+1)+'项为偶数,值为：'+item);\n      }\n\t  return item % 2;\n\t});\n\tvar everyResult2 = everyArr2.every(function(item, index, arr){\n      if (!(item % 2)) {\n        console.log('第'+(index+1)+'项为偶数,值为：'+item); // 第4项为偶数,值为：6\n      }\n\t  return item % 2;\n\t});\n\tconsole.log(everyResult1?'everyArr1的每一项均为基数':'everyArr1的存在某一项不为基数'); // everyArr的每一项均为基数\n\tconsole.log(everyResult2?'everyArr2的每一项均为基数':'everyArr2的存在某一项不为基数'); // everyArr2的存在某一项不为基数\n\t\n\t// 使用some()方法实现\n\tvar someArr1 = [1, 3, 5, 7, 9];\n\tvar someArr2 = [1, 3, 5, 6, 7, 9];\n\tvar someResult1 = someArr1.some(function (item, index, arr) {\n\t  if (!(item % 2)) {\n\t    console.log('第' + (index + 1) + '项为偶数,值为：' + item);\n\t  };\n\t  return !(item % 2);\n\t});\n\tvar someResult2 = someArr2.some(function (item, index, arr) {\n\t  if (!(item % 2)) {\n\t    console.log('第' + (index + 1) + '项为偶数,值为：' + item); // 第4项为偶数,值为：6\n\t  };\n\t  return !(item % 2);\n\t});\n\tconsole.log(!someResult1 ? 'someArr1的每一项均为基数' : 'someArr1的存在某一项不为基数'); // someArr1的每一项均为基数\n\tconsole.log(!someResult2 ? 'someArr2的每一项均为基数' : 'someArr2的存在某一项不为基数'); // someArr2的存在某一项不为基数","source":"_posts/2017-08-05-javascript基础之数组的操作.md","raw":"---\ntitle: javascript基础\ndate: 2017-08-05 19:13:13\ntags: js\n---\n#### javascript基础\n##### 一. js对数组的操作\n###### 1. 数组的基本操作之 —— 增/删 (push(), pop(), unshift(), shift()) 操作\n* 增： push(): 向数组后添加内容，可接受任意数量的参数，会对原数组产生影响,返回修改后数组的长度  \n\n<!--more-->\n\n* 删： pop(): 删除数组最后一个元素，不接收参数，会对原数组产生影响，返回被删除的元素值，如果数组为空，则返回 undefined  \n\n* 增：unshift(): 向数组开头添加内容，可接受任意参数量的参数，会对原数组产生影响，返回修改后的数组的长度  \n\n* 删： shift(): 删除数组第一个元素，不接收参数，会对原数组产生影响，返回被删除的元素值，如果数组为空，则返回 undefined\n\n\t\tvar pushNumber = [1, 2, 3, 4, 5, 6];\n\t\tvar pushResult1 = pushNumber.push(7, '帅气');\n\t\tconsole.log(pushResult1); // 8\n\t\tconsole.log(pushNumber); // [1, 2, 3, 4, 5, 6, 7, '帅气']\n\t\tvar pushResult2 = pushNumber.unshift([7, '帅气']); // 注意添加的是一个数组，为一项\n\t\tconsole.log(pushResult2); // 9 \n\t\tconsole.log(pushNumber); // [[7, '帅气'], 1, 2, 3, 4, 5, 6, 7, '帅气'];\n\t\t\n\t\tvar popNumber = [1, 2, 3, 4, 5, 6];\n\t\tvar popResult1 = popNumber.pop();\n\t\tconsole.log(popResult1); // 6\n\t\tconsole.log(popNumber); // [1, 2, 3, 4, 5]\n\t\tvar popResult2 = popNumber.shift();\n\t\tconsole.log(popResult2); // 1\n\t\tconsole.log(popNumber); // [2, 3, 4, 5]\n\n###### 2. 数组的基本操作之 —— 通过指定索引对指定位置添加或者删除相应位置的元素(splice(), slice())\n> 说明：  \n> splice(): 从数组中添加或删除元素，返回被删除的项目，如果是添加，则返回一个空数组（注：会对原数组进行更改，获取的是新的数组），使用如下：  \n> a. 使用splice()方法添加元素：splice(index, 0, data1, data2, ...)，添加时，splice()方法返回一个空数组;  \n> 参数解析： index(插入的元素的起始位置，值为1，就是第一位开始，并非索引值), 0(删除的个数), data1/data2/...(添加的元素)；  \n\n\t// 向数组第一项之后插入新值\n\tvar spliceAddArr = [1, 2, 3, 4, 5, 6];\n\tvar spliceAddResult = spliceAddArr.splice(1, 0, 'a', 'b', 'c');\n\tconsole.log('spliceAddArr: ', spliceAddArr, '; spliceAddResult: ', spliceAddResult); // spliceAddArr: [1, \"a\", \"b\", \"c\", 2, 3, 4, 5, 6] ; spliceAddResult: []\n\n> b.1 使用splice()方法删除元素： splice(index, 3)，删除时，splice()方法返回被删除的元素的数组集合（注：会对原数组进行更改，原数组变更为删除之后的新数组）  \n> 参数解析： index(删除元素的起始位置，值为1，就是从第一位开始，并非索引值)，3(删除的个数)  \n> b.2 使用splice()方法删除元素的同时添加元素： splice(index, 3, data1, data2, ...)  \n> 参数解析： index(删除元素的起始位置，值为1，就是从第一位开始，并非索引值)，3(删除的个数)，data1/data2/...（添加的元素）；  \n\n\t// 使用splice()删除元素，返回被删除元素\n\tvar spliceDelArr = [1, 2, 3, 4, 5, 6];\n\tvar spliceDelResult = spliceDelArr.splice(1, 3);\n\tconsole.log('spliceDelArr: ', spliceDelArr, '; spliceDelResult: ', spliceDelResult); // spliceDelArr: [1, 5, 6] ; spliceDelResult: [2, 3, 4]\n\t\n\t// 使用splice()删除元素的同时添加元素\n\tvar spliceAddArr = [1, 2, 3, 4, 5, 6];\n\tvar spliceAddResult = spliceAddArr.splice(1, 3, 'a', 'b', 'c');\n\tconsole.log('spliceAddArr: ', spliceAddArr, '; spliceAddResult: ', spliceAddResult); // spliceDelArr: [1, \"a\", \"b\", \"c\", 5, 6] ; spliceDelResult: [2, 3, 4]\n\n> 注： 使用splice(),不管是用来添加还是删除元素，第一个参数都可以接受一个负数作为参数，与正数相比：  \n> 相同之处：  \n> 使用splice()添加元素，都是从起始位置的之后添加，即如果是正3，即从起始位置往后数3位添加，即从第三第四位中间添加元素，若为负数-3，即从后往前数三位的后一位，即从后往前数第三位到第四位中间添加，如果第一个参数，大于数组的实际长度，则从数组的末尾开始添加。  \n> 不同之处：  \n> 使用splice()删除元素，如果是正数3，如： splice(3, 3),即从开始位置往后数三位，从第四位开始删除三项，实际删除的是第四，第五，第六项，而当为负数-3时，如： splice(-3, 3)，即从后往前数三位，从倒数第三位开始删除，并不是倒数第四位，实际删除的项为倒数第三项，倒数第二项，倒数第一项三项。  \n> 如果删除的项数大于起始位置到数组的结束位置的项数，则默认到数组结束位置停止。  \n\t\n\t// splice()添加，index为正数时\n\tvar arr1 = [1, 2, 3, 4, 5];\n\tvar arrRes1 = arr1.splice(3, 0, 'a', 'b', 'c');\n\tconsole.log('arr1: ', arr1, '; arrRes1:', arrRes1); // arr1: [1, 2, 3, 'a', 'b', 'c', 4, 5] ； arrRes1： []\n\n\t// splice()添加，index为负数时\n\tvar arr2 = [1, 2, 3, 4, 5];\n\tvar arrRes2 = arr2.splice(-3, 0, 'a', 'b', 'c');\n\tconsole.log('arr2: ', arr2, '; arrRes2:', arrRes2); // arr2: [1, 2, \"a\", \"b\", \"c\", 3, 4, 5] ; arrRes2: []\n\n\t// splice()删除，index为正数时\n\tvar arr3 = [1, 2, 3, 4, 5, 6, 7];\n\tvar arrRes3 = arr3.splice(3, 3, 'a', 'b', 'c');\n\tconsole.log('arr3: ', arr3, '; arrRes3:', arrRes3); // arr3: [1, 2, 3, \"a\", \"b\", \"c\", 7] ； arrRes3： [4, 5, 6]\n\n\t// splice()删除，index为正数时\n\tvar arr4 = [1, 2, 3, 4, 5, 6, 7];\n\tvar arrRes4 = arr4.splice(-3, 3, 'a', 'b', 'c');\n\tconsole.log('arr4: ', arr4, '; arrRes4:', arrRes4); // arr3: [1, 2, 3, 4, \"a\", \"b\", \"c\"] ； arrRes3： [5, 6, 7]\n\n> slice()使用说明：用于截取数组，返回截取到的新的数组，此方法可以作用于字符串属性（注：不会影响原数组）;  \n> 此方法接受两个参数，slice(start, end)：  \n> start: 必传，截取开始位置的下标,  \n> end: 可传，截取结束的位置下标索引，不包括当前下标对应的元素，不传为数组结束。  \n\n\tvar sliceArr = [1, 2, 3, 4, 5, 6, 7];\n\tvar sliceRes0 = sliceArr.slice(2); // 实际截取的为：第三项到数组结束\n\tvar sliceRes1 = sliceArr.slice(2, 4); // 实际截取的为：第三项，第四项\n\tvar sliceRes2 = sliceArr.slice(-2); // 实际截取的为：第三项，第四项\n\tvar sliceRes3 = sliceArr.slice(-9); // 从后往前第九位，数组长度不够，从第一项开始截取到数组结束\n\tvar sliceRes4 = sliceArr.slice(-4, -2); // 实际截取的为从倒数第四项到倒数第二项：即为倒数第四项，倒数第五项两项\n\tvar sliceRes5 = sliceArr.slice(-4, -6); // 无匹配项，返回一个空数组\n\tvar sliceRes6 = sliceArr.slice(1, -2); // 从索引为1的位置开始，到倒数第二项，不包括倒数第二项\n\tvar sliceRes7 = sliceArr.slice(9); // 无匹配项，返回一个空数组\n\tconsole.log('sliceArr: ', sliceArr, '； sliceRes0: ', sliceRes0); // sliceArr1: [1, 2, 3, 4, 5, 6, 7] ; sliceRes0: [3, 4, 5, 6, 7]\n\tconsole.log('sliceRes1: ', sliceRes1); // sliceRes1: [3, 4]\n\tconsole.log('sliceRes2: ', sliceRes2); // sliceRes2: [6, 7]\n\tconsole.log('sliceRes3: ', sliceRes3); // sliceRes3: [1, 2, 3, 4, 5, 6, 7]\n\tconsole.log('sliceRes4: ', sliceRes4); // sliceRes4: [4, 5]\n\tconsole.log('sliceRes5: ', sliceRes5); // sliceRes5: []\n\tconsole.log('sliceRes6: ', sliceRes6); // sliceRes6: [2, 3, 4, 5]\n\tconsole.log('sliceRes7: ', sliceRes7); // sliceRes7: []\n\n###### 3. 数组的基本操作之 —— 对数组的每一项进行操作(map(), forEach())\n> 相同点:  \n> 1. 都是循环遍历数组中每一项  \n> 2. map和forEach每次执行匿名函数时都支持3个参数，参数分别是item(当前项)，index(索引值)，arr(原数组)  \n> 3. 匿名函数中的this都指向 window  \n> 4. 只能遍历数组  \n> 5. 都不会改变原数组  \n> \n> 区别：  \n> map方法：  \n> 1. map方法返回一个新的数组，数组中的元素为原始数组调用函数处理之后的值  \n> 2. map方法不会对空数组进行检测(即不会执行匿名函数，若为空数组，则调用map方法后也返回一个空数组)，map方法不会改变原始数组  \n> 3. 浏览器支持： chrome / Safari 1.5+ / opera / IE9+  \n> forEach方法：  \n> 1. forEach()方法用来调用数组的每个元素，将元素传给回调函数  \n> 2. forEach()方法不会对空数组进行检测，对于空数组是不会调用匿名函数的，注意，无论数组是否为空，调用forEach方法，返回值均为 undefined\n\n\t// map方法\n\tvar mapArr = [1, 2, 3, 4, 5];\n    var mapResult = mapArr.map(function(item, index, arr){\n      console.log(this); // window\n      console.log('原始数组mapArr: ', arr); // 原始数组mapArr: [1, 2, 3, 4, 5]\n      return item+1;\n    })\n    console.log('mapArr:', mapArr, '; mapResult: ', mapResult); // mapArr: [1, 2, 3, 4, 5] ; mapResult: [2, 3, 4, 5, 6]\n\n\t// 若为空数组，调用map方法，返回一个空数组，匿名函数不会执行\n\tvar empArr = [];\n\tvar mapEmpResult = empArr.map(function(){item, index, arr}{\n\t  // 空数组调用map方法，函数体不会执行\n      console.log(this);\n      console.log('原始数组mapArr: ', arr);\n      return item+1;\n\t})；\n\tconsole.log('empArr:', empArr, '; mapEmpResult: ', mapEmpResult); // empArr: [] ; mapEmpResult: []\n\n\t// forEach方法\n\tvar forEachArr = [1, 2, 3, 4, 5];\n\tvar forEachResult = forEachArr.forEach(function(item, index, arr){ // 调用forEach()方法，返回值均为 undefined\n\t  console.log(this); // window\n\t  console.log('原始数组forEachArr：', arr); // 原始数组forEachArr： [1, 2, 3, 4, 5]\n\t  return item+1;\n\t})\n    console.log('forEachArr:', forEachArr, '; forEachResult: ', forEachResult); // forEachArr: [1, 2, 3, 4, 5] ; forEachResult: undefined\n\n###### 4. 数组的基本操作之 —— 对数组的每一项进行操作（ filter() ）\n> 说明： 遍历每一项数组，接收一个匿名函数作为参数，函数接收三个参数，参数item(遍历得到的每一项数组值)，index（索引值），arr(数组本身)， 返回一个结果为true的item组成的新数组，不会影响原数组  \n\t\n\t// 需求：获取成绩合格的学生名单\n\tvar students = [\n      {name: '张三', age: 18, scroe: 89},\n      {name: '李四', age: 17, scroe: 71},\n      {name: '王五', age: 18, scroe: 56},\n      {name: '赵六', age: 19, scroe: 94},\n      {name: '小明', age: 18, scroe: 48},\n      {name: '小红', age: 19, scroe: 60},\n    ];\n\tvar studentsResult = students.filter(function(item){\n      if (item.scroe >= 60) {\n        return {\n          name: item.name,\n          age: item.age,\n          score: item.scroe\n        }\n      }\n    });\n    console.log(studentsResult); // 输出如下结果\n\t// [{name: \"张三\", age: 18, scroe: 89},\n\t// {name: \"李四\", age: 17, scroe: 71},\n\t// {name: \"赵六\", age: 19, scroe: 94},\n\t// {name: \"小红\", age: 19, scroe: 60}]\n\n###### 5. 数组的基本操作之 —— 对数组的迭代方法(every(), some())方法\n> 说明：every()和some()都是对js中数组的迭代方法，区别如下：  \n> 相同点：  \n> 1. 均接收一个匿名函数作为参数，函数接收三个参数，参数item(每一项),index（索引值），arr(原始数组)  \n> 2. 均对数组的每一项运行指定的匿名函数\n> \n> 不同点:  \n> every(): 对数组的每一项运行给定的函数，如果该函数每一项都返回 true, 则返回 true，若存在某项返回false，则终止函数迭代，返回false; (可用来判断是不是所有，类似于逻辑 &&)  \n> some(): 对数组的每一项运行给定的函数，如果该函数存在某一项返回 true, 函数终止，并返回 true; (可用来判断有没有，类似于逻辑 ||)\n\n\t// 判断数组是是否全为基数\n\t// 使用every()方法实现\n\tvar everyArr1 = [1, 3, 5, 7, 9];\n\tvar everyArr2 = [1, 3, 5, 6, 7, 9];\n\tvar everyResult1 = everyArr1.every(function(item, index, arr){\n      if (!(item % 2)) {\n        console.log('第'+(index+1)+'项为偶数,值为：'+item);\n      }\n\t  return item % 2;\n\t});\n\tvar everyResult2 = everyArr2.every(function(item, index, arr){\n      if (!(item % 2)) {\n        console.log('第'+(index+1)+'项为偶数,值为：'+item); // 第4项为偶数,值为：6\n      }\n\t  return item % 2;\n\t});\n\tconsole.log(everyResult1?'everyArr1的每一项均为基数':'everyArr1的存在某一项不为基数'); // everyArr的每一项均为基数\n\tconsole.log(everyResult2?'everyArr2的每一项均为基数':'everyArr2的存在某一项不为基数'); // everyArr2的存在某一项不为基数\n\t\n\t// 使用some()方法实现\n\tvar someArr1 = [1, 3, 5, 7, 9];\n\tvar someArr2 = [1, 3, 5, 6, 7, 9];\n\tvar someResult1 = someArr1.some(function (item, index, arr) {\n\t  if (!(item % 2)) {\n\t    console.log('第' + (index + 1) + '项为偶数,值为：' + item);\n\t  };\n\t  return !(item % 2);\n\t});\n\tvar someResult2 = someArr2.some(function (item, index, arr) {\n\t  if (!(item % 2)) {\n\t    console.log('第' + (index + 1) + '项为偶数,值为：' + item); // 第4项为偶数,值为：6\n\t  };\n\t  return !(item % 2);\n\t});\n\tconsole.log(!someResult1 ? 'someArr1的每一项均为基数' : 'someArr1的存在某一项不为基数'); // someArr1的每一项均为基数\n\tconsole.log(!someResult2 ? 'someArr2的每一项均为基数' : 'someArr2的存在某一项不为基数'); // someArr2的存在某一项不为基数","slug":"2017-08-05-javascript基础之数组的操作","published":1,"updated":"2019-03-20T14:35:19.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxaj7gv7001kgp9ah947lqt3","content":"<h4 id=\"javascript基础\"><a href=\"#javascript基础\" class=\"headerlink\" title=\"javascript基础\"></a>javascript基础</h4><h5 id=\"一-js对数组的操作\"><a href=\"#一-js对数组的操作\" class=\"headerlink\" title=\"一. js对数组的操作\"></a>一. js对数组的操作</h5><h6 id=\"1-数组的基本操作之-——-增-删-push-pop-unshift-shift-操作\"><a href=\"#1-数组的基本操作之-——-增-删-push-pop-unshift-shift-操作\" class=\"headerlink\" title=\"1. 数组的基本操作之 —— 增/删 (push(), pop(), unshift(), shift()) 操作\"></a>1. 数组的基本操作之 —— 增/删 (push(), pop(), unshift(), shift()) 操作</h6><ul>\n<li>增： push(): 向数组后添加内容，可接受任意数量的参数，会对原数组产生影响,返回修改后数组的长度  </li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>删： pop(): 删除数组最后一个元素，不接收参数，会对原数组产生影响，返回被删除的元素值，如果数组为空，则返回 undefined  </p>\n</li>\n<li><p>增：unshift(): 向数组开头添加内容，可接受任意参数量的参数，会对原数组产生影响，返回修改后的数组的长度  </p>\n</li>\n<li><p>删： shift(): 删除数组第一个元素，不接收参数，会对原数组产生影响，返回被删除的元素值，如果数组为空，则返回 undefined</p>\n<pre><code>var pushNumber = [1, 2, 3, 4, 5, 6];\nvar pushResult1 = pushNumber.push(7, &apos;帅气&apos;);\nconsole.log(pushResult1); // 8\nconsole.log(pushNumber); // [1, 2, 3, 4, 5, 6, 7, &apos;帅气&apos;]\nvar pushResult2 = pushNumber.unshift([7, &apos;帅气&apos;]); // 注意添加的是一个数组，为一项\nconsole.log(pushResult2); // 9 \nconsole.log(pushNumber); // [[7, &apos;帅气&apos;], 1, 2, 3, 4, 5, 6, 7, &apos;帅气&apos;];\n\nvar popNumber = [1, 2, 3, 4, 5, 6];\nvar popResult1 = popNumber.pop();\nconsole.log(popResult1); // 6\nconsole.log(popNumber); // [1, 2, 3, 4, 5]\nvar popResult2 = popNumber.shift();\nconsole.log(popResult2); // 1\nconsole.log(popNumber); // [2, 3, 4, 5]\n</code></pre></li>\n</ul>\n<h6 id=\"2-数组的基本操作之-——-通过指定索引对指定位置添加或者删除相应位置的元素-splice-slice\"><a href=\"#2-数组的基本操作之-——-通过指定索引对指定位置添加或者删除相应位置的元素-splice-slice\" class=\"headerlink\" title=\"2. 数组的基本操作之 —— 通过指定索引对指定位置添加或者删除相应位置的元素(splice(), slice())\"></a>2. 数组的基本操作之 —— 通过指定索引对指定位置添加或者删除相应位置的元素(splice(), slice())</h6><blockquote>\n<p>说明：<br>splice(): 从数组中添加或删除元素，返回被删除的项目，如果是添加，则返回一个空数组（注：会对原数组进行更改，获取的是新的数组），使用如下：<br>a. 使用splice()方法添加元素：splice(index, 0, data1, data2, …)，添加时，splice()方法返回一个空数组;<br>参数解析： index(插入的元素的起始位置，值为1，就是第一位开始，并非索引值), 0(删除的个数), data1/data2/…(添加的元素)；  </p>\n</blockquote>\n<pre><code>// 向数组第一项之后插入新值\nvar spliceAddArr = [1, 2, 3, 4, 5, 6];\nvar spliceAddResult = spliceAddArr.splice(1, 0, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);\nconsole.log(&apos;spliceAddArr: &apos;, spliceAddArr, &apos;; spliceAddResult: &apos;, spliceAddResult); // spliceAddArr: [1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 2, 3, 4, 5, 6] ; spliceAddResult: []\n</code></pre><blockquote>\n<p>b.1 使用splice()方法删除元素： splice(index, 3)，删除时，splice()方法返回被删除的元素的数组集合（注：会对原数组进行更改，原数组变更为删除之后的新数组）<br>参数解析： index(删除元素的起始位置，值为1，就是从第一位开始，并非索引值)，3(删除的个数)<br>b.2 使用splice()方法删除元素的同时添加元素： splice(index, 3, data1, data2, …)<br>参数解析： index(删除元素的起始位置，值为1，就是从第一位开始，并非索引值)，3(删除的个数)，data1/data2/…（添加的元素）；  </p>\n</blockquote>\n<pre><code>// 使用splice()删除元素，返回被删除元素\nvar spliceDelArr = [1, 2, 3, 4, 5, 6];\nvar spliceDelResult = spliceDelArr.splice(1, 3);\nconsole.log(&apos;spliceDelArr: &apos;, spliceDelArr, &apos;; spliceDelResult: &apos;, spliceDelResult); // spliceDelArr: [1, 5, 6] ; spliceDelResult: [2, 3, 4]\n\n// 使用splice()删除元素的同时添加元素\nvar spliceAddArr = [1, 2, 3, 4, 5, 6];\nvar spliceAddResult = spliceAddArr.splice(1, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);\nconsole.log(&apos;spliceAddArr: &apos;, spliceAddArr, &apos;; spliceAddResult: &apos;, spliceAddResult); // spliceDelArr: [1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 5, 6] ; spliceDelResult: [2, 3, 4]\n</code></pre><blockquote>\n<p>注： 使用splice(),不管是用来添加还是删除元素，第一个参数都可以接受一个负数作为参数，与正数相比：<br>相同之处：<br>使用splice()添加元素，都是从起始位置的之后添加，即如果是正3，即从起始位置往后数3位添加，即从第三第四位中间添加元素，若为负数-3，即从后往前数三位的后一位，即从后往前数第三位到第四位中间添加，如果第一个参数，大于数组的实际长度，则从数组的末尾开始添加。<br>不同之处：<br>使用splice()删除元素，如果是正数3，如： splice(3, 3),即从开始位置往后数三位，从第四位开始删除三项，实际删除的是第四，第五，第六项，而当为负数-3时，如： splice(-3, 3)，即从后往前数三位，从倒数第三位开始删除，并不是倒数第四位，实际删除的项为倒数第三项，倒数第二项，倒数第一项三项。<br>如果删除的项数大于起始位置到数组的结束位置的项数，则默认到数组结束位置停止。  </p>\n</blockquote>\n<pre><code>// splice()添加，index为正数时\nvar arr1 = [1, 2, 3, 4, 5];\nvar arrRes1 = arr1.splice(3, 0, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);\nconsole.log(&apos;arr1: &apos;, arr1, &apos;; arrRes1:&apos;, arrRes1); // arr1: [1, 2, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 4, 5] ； arrRes1： []\n\n// splice()添加，index为负数时\nvar arr2 = [1, 2, 3, 4, 5];\nvar arrRes2 = arr2.splice(-3, 0, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);\nconsole.log(&apos;arr2: &apos;, arr2, &apos;; arrRes2:&apos;, arrRes2); // arr2: [1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 3, 4, 5] ; arrRes2: []\n\n// splice()删除，index为正数时\nvar arr3 = [1, 2, 3, 4, 5, 6, 7];\nvar arrRes3 = arr3.splice(3, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);\nconsole.log(&apos;arr3: &apos;, arr3, &apos;; arrRes3:&apos;, arrRes3); // arr3: [1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 7] ； arrRes3： [4, 5, 6]\n\n// splice()删除，index为正数时\nvar arr4 = [1, 2, 3, 4, 5, 6, 7];\nvar arrRes4 = arr4.splice(-3, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);\nconsole.log(&apos;arr4: &apos;, arr4, &apos;; arrRes4:&apos;, arrRes4); // arr3: [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] ； arrRes3： [5, 6, 7]\n</code></pre><blockquote>\n<p>slice()使用说明：用于截取数组，返回截取到的新的数组，此方法可以作用于字符串属性（注：不会影响原数组）;<br>此方法接受两个参数，slice(start, end)：<br>start: 必传，截取开始位置的下标,<br>end: 可传，截取结束的位置下标索引，不包括当前下标对应的元素，不传为数组结束。  </p>\n</blockquote>\n<pre><code>var sliceArr = [1, 2, 3, 4, 5, 6, 7];\nvar sliceRes0 = sliceArr.slice(2); // 实际截取的为：第三项到数组结束\nvar sliceRes1 = sliceArr.slice(2, 4); // 实际截取的为：第三项，第四项\nvar sliceRes2 = sliceArr.slice(-2); // 实际截取的为：第三项，第四项\nvar sliceRes3 = sliceArr.slice(-9); // 从后往前第九位，数组长度不够，从第一项开始截取到数组结束\nvar sliceRes4 = sliceArr.slice(-4, -2); // 实际截取的为从倒数第四项到倒数第二项：即为倒数第四项，倒数第五项两项\nvar sliceRes5 = sliceArr.slice(-4, -6); // 无匹配项，返回一个空数组\nvar sliceRes6 = sliceArr.slice(1, -2); // 从索引为1的位置开始，到倒数第二项，不包括倒数第二项\nvar sliceRes7 = sliceArr.slice(9); // 无匹配项，返回一个空数组\nconsole.log(&apos;sliceArr: &apos;, sliceArr, &apos;； sliceRes0: &apos;, sliceRes0); // sliceArr1: [1, 2, 3, 4, 5, 6, 7] ; sliceRes0: [3, 4, 5, 6, 7]\nconsole.log(&apos;sliceRes1: &apos;, sliceRes1); // sliceRes1: [3, 4]\nconsole.log(&apos;sliceRes2: &apos;, sliceRes2); // sliceRes2: [6, 7]\nconsole.log(&apos;sliceRes3: &apos;, sliceRes3); // sliceRes3: [1, 2, 3, 4, 5, 6, 7]\nconsole.log(&apos;sliceRes4: &apos;, sliceRes4); // sliceRes4: [4, 5]\nconsole.log(&apos;sliceRes5: &apos;, sliceRes5); // sliceRes5: []\nconsole.log(&apos;sliceRes6: &apos;, sliceRes6); // sliceRes6: [2, 3, 4, 5]\nconsole.log(&apos;sliceRes7: &apos;, sliceRes7); // sliceRes7: []\n</code></pre><h6 id=\"3-数组的基本操作之-——-对数组的每一项进行操作-map-forEach\"><a href=\"#3-数组的基本操作之-——-对数组的每一项进行操作-map-forEach\" class=\"headerlink\" title=\"3. 数组的基本操作之 —— 对数组的每一项进行操作(map(), forEach())\"></a>3. 数组的基本操作之 —— 对数组的每一项进行操作(map(), forEach())</h6><blockquote>\n<p>相同点:  </p>\n<ol>\n<li>都是循环遍历数组中每一项  </li>\n<li>map和forEach每次执行匿名函数时都支持3个参数，参数分别是item(当前项)，index(索引值)，arr(原数组)  </li>\n<li>匿名函数中的this都指向 window  </li>\n<li>只能遍历数组  </li>\n<li>都不会改变原数组  </li>\n</ol>\n<p>区别：<br>map方法：  </p>\n<ol>\n<li>map方法返回一个新的数组，数组中的元素为原始数组调用函数处理之后的值  </li>\n<li>map方法不会对空数组进行检测(即不会执行匿名函数，若为空数组，则调用map方法后也返回一个空数组)，map方法不会改变原始数组  </li>\n<li>浏览器支持： chrome / Safari 1.5+ / opera / IE9+<br>forEach方法：  </li>\n<li>forEach()方法用来调用数组的每个元素，将元素传给回调函数  </li>\n<li>forEach()方法不会对空数组进行检测，对于空数组是不会调用匿名函数的，注意，无论数组是否为空，调用forEach方法，返回值均为 undefined</li>\n</ol>\n</blockquote>\n<pre><code>// map方法\nvar mapArr = [1, 2, 3, 4, 5];\nvar mapResult = mapArr.map(function(item, index, arr){\n  console.log(this); // window\n  console.log(&apos;原始数组mapArr: &apos;, arr); // 原始数组mapArr: [1, 2, 3, 4, 5]\n  return item+1;\n})\nconsole.log(&apos;mapArr:&apos;, mapArr, &apos;; mapResult: &apos;, mapResult); // mapArr: [1, 2, 3, 4, 5] ; mapResult: [2, 3, 4, 5, 6]\n\n// 若为空数组，调用map方法，返回一个空数组，匿名函数不会执行\nvar empArr = [];\nvar mapEmpResult = empArr.map(function(){item, index, arr}{\n  // 空数组调用map方法，函数体不会执行\n  console.log(this);\n  console.log(&apos;原始数组mapArr: &apos;, arr);\n  return item+1;\n})；\nconsole.log(&apos;empArr:&apos;, empArr, &apos;; mapEmpResult: &apos;, mapEmpResult); // empArr: [] ; mapEmpResult: []\n\n// forEach方法\nvar forEachArr = [1, 2, 3, 4, 5];\nvar forEachResult = forEachArr.forEach(function(item, index, arr){ // 调用forEach()方法，返回值均为 undefined\n  console.log(this); // window\n  console.log(&apos;原始数组forEachArr：&apos;, arr); // 原始数组forEachArr： [1, 2, 3, 4, 5]\n  return item+1;\n})\nconsole.log(&apos;forEachArr:&apos;, forEachArr, &apos;; forEachResult: &apos;, forEachResult); // forEachArr: [1, 2, 3, 4, 5] ; forEachResult: undefined\n</code></pre><h6 id=\"4-数组的基本操作之-——-对数组的每一项进行操作（-filter-）\"><a href=\"#4-数组的基本操作之-——-对数组的每一项进行操作（-filter-）\" class=\"headerlink\" title=\"4. 数组的基本操作之 —— 对数组的每一项进行操作（ filter() ）\"></a>4. 数组的基本操作之 —— 对数组的每一项进行操作（ filter() ）</h6><blockquote>\n<p>说明： 遍历每一项数组，接收一个匿名函数作为参数，函数接收三个参数，参数item(遍历得到的每一项数组值)，index（索引值），arr(数组本身)， 返回一个结果为true的item组成的新数组，不会影响原数组  </p>\n</blockquote>\n<pre><code>// 需求：获取成绩合格的学生名单\nvar students = [\n  {name: &apos;张三&apos;, age: 18, scroe: 89},\n  {name: &apos;李四&apos;, age: 17, scroe: 71},\n  {name: &apos;王五&apos;, age: 18, scroe: 56},\n  {name: &apos;赵六&apos;, age: 19, scroe: 94},\n  {name: &apos;小明&apos;, age: 18, scroe: 48},\n  {name: &apos;小红&apos;, age: 19, scroe: 60},\n];\nvar studentsResult = students.filter(function(item){\n  if (item.scroe &gt;= 60) {\n    return {\n      name: item.name,\n      age: item.age,\n      score: item.scroe\n    }\n  }\n});\nconsole.log(studentsResult); // 输出如下结果\n// [{name: &quot;张三&quot;, age: 18, scroe: 89},\n// {name: &quot;李四&quot;, age: 17, scroe: 71},\n// {name: &quot;赵六&quot;, age: 19, scroe: 94},\n// {name: &quot;小红&quot;, age: 19, scroe: 60}]\n</code></pre><h6 id=\"5-数组的基本操作之-——-对数组的迭代方法-every-some-方法\"><a href=\"#5-数组的基本操作之-——-对数组的迭代方法-every-some-方法\" class=\"headerlink\" title=\"5. 数组的基本操作之 —— 对数组的迭代方法(every(), some())方法\"></a>5. 数组的基本操作之 —— 对数组的迭代方法(every(), some())方法</h6><blockquote>\n<p>说明：every()和some()都是对js中数组的迭代方法，区别如下：<br>相同点：  </p>\n<ol>\n<li>均接收一个匿名函数作为参数，函数接收三个参数，参数item(每一项),index（索引值），arr(原始数组)  </li>\n<li>均对数组的每一项运行指定的匿名函数</li>\n</ol>\n<p>不同点:<br>every(): 对数组的每一项运行给定的函数，如果该函数每一项都返回 true, 则返回 true，若存在某项返回false，则终止函数迭代，返回false; (可用来判断是不是所有，类似于逻辑 &amp;&amp;)<br>some(): 对数组的每一项运行给定的函数，如果该函数存在某一项返回 true, 函数终止，并返回 true; (可用来判断有没有，类似于逻辑 ||)</p>\n</blockquote>\n<pre><code>// 判断数组是是否全为基数\n// 使用every()方法实现\nvar everyArr1 = [1, 3, 5, 7, 9];\nvar everyArr2 = [1, 3, 5, 6, 7, 9];\nvar everyResult1 = everyArr1.every(function(item, index, arr){\n  if (!(item % 2)) {\n    console.log(&apos;第&apos;+(index+1)+&apos;项为偶数,值为：&apos;+item);\n  }\n  return item % 2;\n});\nvar everyResult2 = everyArr2.every(function(item, index, arr){\n  if (!(item % 2)) {\n    console.log(&apos;第&apos;+(index+1)+&apos;项为偶数,值为：&apos;+item); // 第4项为偶数,值为：6\n  }\n  return item % 2;\n});\nconsole.log(everyResult1?&apos;everyArr1的每一项均为基数&apos;:&apos;everyArr1的存在某一项不为基数&apos;); // everyArr的每一项均为基数\nconsole.log(everyResult2?&apos;everyArr2的每一项均为基数&apos;:&apos;everyArr2的存在某一项不为基数&apos;); // everyArr2的存在某一项不为基数\n\n// 使用some()方法实现\nvar someArr1 = [1, 3, 5, 7, 9];\nvar someArr2 = [1, 3, 5, 6, 7, 9];\nvar someResult1 = someArr1.some(function (item, index, arr) {\n  if (!(item % 2)) {\n    console.log(&apos;第&apos; + (index + 1) + &apos;项为偶数,值为：&apos; + item);\n  };\n  return !(item % 2);\n});\nvar someResult2 = someArr2.some(function (item, index, arr) {\n  if (!(item % 2)) {\n    console.log(&apos;第&apos; + (index + 1) + &apos;项为偶数,值为：&apos; + item); // 第4项为偶数,值为：6\n  };\n  return !(item % 2);\n});\nconsole.log(!someResult1 ? &apos;someArr1的每一项均为基数&apos; : &apos;someArr1的存在某一项不为基数&apos;); // someArr1的每一项均为基数\nconsole.log(!someResult2 ? &apos;someArr2的每一项均为基数&apos; : &apos;someArr2的存在某一项不为基数&apos;); // someArr2的存在某一项不为基数\n</code></pre>","site":{"data":{}},"excerpt":"<h4 id=\"javascript基础\"><a href=\"#javascript基础\" class=\"headerlink\" title=\"javascript基础\"></a>javascript基础</h4><h5 id=\"一-js对数组的操作\"><a href=\"#一-js对数组的操作\" class=\"headerlink\" title=\"一. js对数组的操作\"></a>一. js对数组的操作</h5><h6 id=\"1-数组的基本操作之-——-增-删-push-pop-unshift-shift-操作\"><a href=\"#1-数组的基本操作之-——-增-删-push-pop-unshift-shift-操作\" class=\"headerlink\" title=\"1. 数组的基本操作之 —— 增/删 (push(), pop(), unshift(), shift()) 操作\"></a>1. 数组的基本操作之 —— 增/删 (push(), pop(), unshift(), shift()) 操作</h6><ul>\n<li>增： push(): 向数组后添加内容，可接受任意数量的参数，会对原数组产生影响,返回修改后数组的长度  </li>\n</ul>","more":"<ul>\n<li><p>删： pop(): 删除数组最后一个元素，不接收参数，会对原数组产生影响，返回被删除的元素值，如果数组为空，则返回 undefined  </p>\n</li>\n<li><p>增：unshift(): 向数组开头添加内容，可接受任意参数量的参数，会对原数组产生影响，返回修改后的数组的长度  </p>\n</li>\n<li><p>删： shift(): 删除数组第一个元素，不接收参数，会对原数组产生影响，返回被删除的元素值，如果数组为空，则返回 undefined</p>\n<pre><code>var pushNumber = [1, 2, 3, 4, 5, 6];\nvar pushResult1 = pushNumber.push(7, &apos;帅气&apos;);\nconsole.log(pushResult1); // 8\nconsole.log(pushNumber); // [1, 2, 3, 4, 5, 6, 7, &apos;帅气&apos;]\nvar pushResult2 = pushNumber.unshift([7, &apos;帅气&apos;]); // 注意添加的是一个数组，为一项\nconsole.log(pushResult2); // 9 \nconsole.log(pushNumber); // [[7, &apos;帅气&apos;], 1, 2, 3, 4, 5, 6, 7, &apos;帅气&apos;];\n\nvar popNumber = [1, 2, 3, 4, 5, 6];\nvar popResult1 = popNumber.pop();\nconsole.log(popResult1); // 6\nconsole.log(popNumber); // [1, 2, 3, 4, 5]\nvar popResult2 = popNumber.shift();\nconsole.log(popResult2); // 1\nconsole.log(popNumber); // [2, 3, 4, 5]\n</code></pre></li>\n</ul>\n<h6 id=\"2-数组的基本操作之-——-通过指定索引对指定位置添加或者删除相应位置的元素-splice-slice\"><a href=\"#2-数组的基本操作之-——-通过指定索引对指定位置添加或者删除相应位置的元素-splice-slice\" class=\"headerlink\" title=\"2. 数组的基本操作之 —— 通过指定索引对指定位置添加或者删除相应位置的元素(splice(), slice())\"></a>2. 数组的基本操作之 —— 通过指定索引对指定位置添加或者删除相应位置的元素(splice(), slice())</h6><blockquote>\n<p>说明：<br>splice(): 从数组中添加或删除元素，返回被删除的项目，如果是添加，则返回一个空数组（注：会对原数组进行更改，获取的是新的数组），使用如下：<br>a. 使用splice()方法添加元素：splice(index, 0, data1, data2, …)，添加时，splice()方法返回一个空数组;<br>参数解析： index(插入的元素的起始位置，值为1，就是第一位开始，并非索引值), 0(删除的个数), data1/data2/…(添加的元素)；  </p>\n</blockquote>\n<pre><code>// 向数组第一项之后插入新值\nvar spliceAddArr = [1, 2, 3, 4, 5, 6];\nvar spliceAddResult = spliceAddArr.splice(1, 0, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);\nconsole.log(&apos;spliceAddArr: &apos;, spliceAddArr, &apos;; spliceAddResult: &apos;, spliceAddResult); // spliceAddArr: [1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 2, 3, 4, 5, 6] ; spliceAddResult: []\n</code></pre><blockquote>\n<p>b.1 使用splice()方法删除元素： splice(index, 3)，删除时，splice()方法返回被删除的元素的数组集合（注：会对原数组进行更改，原数组变更为删除之后的新数组）<br>参数解析： index(删除元素的起始位置，值为1，就是从第一位开始，并非索引值)，3(删除的个数)<br>b.2 使用splice()方法删除元素的同时添加元素： splice(index, 3, data1, data2, …)<br>参数解析： index(删除元素的起始位置，值为1，就是从第一位开始，并非索引值)，3(删除的个数)，data1/data2/…（添加的元素）；  </p>\n</blockquote>\n<pre><code>// 使用splice()删除元素，返回被删除元素\nvar spliceDelArr = [1, 2, 3, 4, 5, 6];\nvar spliceDelResult = spliceDelArr.splice(1, 3);\nconsole.log(&apos;spliceDelArr: &apos;, spliceDelArr, &apos;; spliceDelResult: &apos;, spliceDelResult); // spliceDelArr: [1, 5, 6] ; spliceDelResult: [2, 3, 4]\n\n// 使用splice()删除元素的同时添加元素\nvar spliceAddArr = [1, 2, 3, 4, 5, 6];\nvar spliceAddResult = spliceAddArr.splice(1, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);\nconsole.log(&apos;spliceAddArr: &apos;, spliceAddArr, &apos;; spliceAddResult: &apos;, spliceAddResult); // spliceDelArr: [1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 5, 6] ; spliceDelResult: [2, 3, 4]\n</code></pre><blockquote>\n<p>注： 使用splice(),不管是用来添加还是删除元素，第一个参数都可以接受一个负数作为参数，与正数相比：<br>相同之处：<br>使用splice()添加元素，都是从起始位置的之后添加，即如果是正3，即从起始位置往后数3位添加，即从第三第四位中间添加元素，若为负数-3，即从后往前数三位的后一位，即从后往前数第三位到第四位中间添加，如果第一个参数，大于数组的实际长度，则从数组的末尾开始添加。<br>不同之处：<br>使用splice()删除元素，如果是正数3，如： splice(3, 3),即从开始位置往后数三位，从第四位开始删除三项，实际删除的是第四，第五，第六项，而当为负数-3时，如： splice(-3, 3)，即从后往前数三位，从倒数第三位开始删除，并不是倒数第四位，实际删除的项为倒数第三项，倒数第二项，倒数第一项三项。<br>如果删除的项数大于起始位置到数组的结束位置的项数，则默认到数组结束位置停止。  </p>\n</blockquote>\n<pre><code>// splice()添加，index为正数时\nvar arr1 = [1, 2, 3, 4, 5];\nvar arrRes1 = arr1.splice(3, 0, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);\nconsole.log(&apos;arr1: &apos;, arr1, &apos;; arrRes1:&apos;, arrRes1); // arr1: [1, 2, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 4, 5] ； arrRes1： []\n\n// splice()添加，index为负数时\nvar arr2 = [1, 2, 3, 4, 5];\nvar arrRes2 = arr2.splice(-3, 0, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);\nconsole.log(&apos;arr2: &apos;, arr2, &apos;; arrRes2:&apos;, arrRes2); // arr2: [1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 3, 4, 5] ; arrRes2: []\n\n// splice()删除，index为正数时\nvar arr3 = [1, 2, 3, 4, 5, 6, 7];\nvar arrRes3 = arr3.splice(3, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);\nconsole.log(&apos;arr3: &apos;, arr3, &apos;; arrRes3:&apos;, arrRes3); // arr3: [1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 7] ； arrRes3： [4, 5, 6]\n\n// splice()删除，index为正数时\nvar arr4 = [1, 2, 3, 4, 5, 6, 7];\nvar arrRes4 = arr4.splice(-3, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);\nconsole.log(&apos;arr4: &apos;, arr4, &apos;; arrRes4:&apos;, arrRes4); // arr3: [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] ； arrRes3： [5, 6, 7]\n</code></pre><blockquote>\n<p>slice()使用说明：用于截取数组，返回截取到的新的数组，此方法可以作用于字符串属性（注：不会影响原数组）;<br>此方法接受两个参数，slice(start, end)：<br>start: 必传，截取开始位置的下标,<br>end: 可传，截取结束的位置下标索引，不包括当前下标对应的元素，不传为数组结束。  </p>\n</blockquote>\n<pre><code>var sliceArr = [1, 2, 3, 4, 5, 6, 7];\nvar sliceRes0 = sliceArr.slice(2); // 实际截取的为：第三项到数组结束\nvar sliceRes1 = sliceArr.slice(2, 4); // 实际截取的为：第三项，第四项\nvar sliceRes2 = sliceArr.slice(-2); // 实际截取的为：第三项，第四项\nvar sliceRes3 = sliceArr.slice(-9); // 从后往前第九位，数组长度不够，从第一项开始截取到数组结束\nvar sliceRes4 = sliceArr.slice(-4, -2); // 实际截取的为从倒数第四项到倒数第二项：即为倒数第四项，倒数第五项两项\nvar sliceRes5 = sliceArr.slice(-4, -6); // 无匹配项，返回一个空数组\nvar sliceRes6 = sliceArr.slice(1, -2); // 从索引为1的位置开始，到倒数第二项，不包括倒数第二项\nvar sliceRes7 = sliceArr.slice(9); // 无匹配项，返回一个空数组\nconsole.log(&apos;sliceArr: &apos;, sliceArr, &apos;； sliceRes0: &apos;, sliceRes0); // sliceArr1: [1, 2, 3, 4, 5, 6, 7] ; sliceRes0: [3, 4, 5, 6, 7]\nconsole.log(&apos;sliceRes1: &apos;, sliceRes1); // sliceRes1: [3, 4]\nconsole.log(&apos;sliceRes2: &apos;, sliceRes2); // sliceRes2: [6, 7]\nconsole.log(&apos;sliceRes3: &apos;, sliceRes3); // sliceRes3: [1, 2, 3, 4, 5, 6, 7]\nconsole.log(&apos;sliceRes4: &apos;, sliceRes4); // sliceRes4: [4, 5]\nconsole.log(&apos;sliceRes5: &apos;, sliceRes5); // sliceRes5: []\nconsole.log(&apos;sliceRes6: &apos;, sliceRes6); // sliceRes6: [2, 3, 4, 5]\nconsole.log(&apos;sliceRes7: &apos;, sliceRes7); // sliceRes7: []\n</code></pre><h6 id=\"3-数组的基本操作之-——-对数组的每一项进行操作-map-forEach\"><a href=\"#3-数组的基本操作之-——-对数组的每一项进行操作-map-forEach\" class=\"headerlink\" title=\"3. 数组的基本操作之 —— 对数组的每一项进行操作(map(), forEach())\"></a>3. 数组的基本操作之 —— 对数组的每一项进行操作(map(), forEach())</h6><blockquote>\n<p>相同点:  </p>\n<ol>\n<li>都是循环遍历数组中每一项  </li>\n<li>map和forEach每次执行匿名函数时都支持3个参数，参数分别是item(当前项)，index(索引值)，arr(原数组)  </li>\n<li>匿名函数中的this都指向 window  </li>\n<li>只能遍历数组  </li>\n<li>都不会改变原数组  </li>\n</ol>\n<p>区别：<br>map方法：  </p>\n<ol>\n<li>map方法返回一个新的数组，数组中的元素为原始数组调用函数处理之后的值  </li>\n<li>map方法不会对空数组进行检测(即不会执行匿名函数，若为空数组，则调用map方法后也返回一个空数组)，map方法不会改变原始数组  </li>\n<li>浏览器支持： chrome / Safari 1.5+ / opera / IE9+<br>forEach方法：  </li>\n<li>forEach()方法用来调用数组的每个元素，将元素传给回调函数  </li>\n<li>forEach()方法不会对空数组进行检测，对于空数组是不会调用匿名函数的，注意，无论数组是否为空，调用forEach方法，返回值均为 undefined</li>\n</ol>\n</blockquote>\n<pre><code>// map方法\nvar mapArr = [1, 2, 3, 4, 5];\nvar mapResult = mapArr.map(function(item, index, arr){\n  console.log(this); // window\n  console.log(&apos;原始数组mapArr: &apos;, arr); // 原始数组mapArr: [1, 2, 3, 4, 5]\n  return item+1;\n})\nconsole.log(&apos;mapArr:&apos;, mapArr, &apos;; mapResult: &apos;, mapResult); // mapArr: [1, 2, 3, 4, 5] ; mapResult: [2, 3, 4, 5, 6]\n\n// 若为空数组，调用map方法，返回一个空数组，匿名函数不会执行\nvar empArr = [];\nvar mapEmpResult = empArr.map(function(){item, index, arr}{\n  // 空数组调用map方法，函数体不会执行\n  console.log(this);\n  console.log(&apos;原始数组mapArr: &apos;, arr);\n  return item+1;\n})；\nconsole.log(&apos;empArr:&apos;, empArr, &apos;; mapEmpResult: &apos;, mapEmpResult); // empArr: [] ; mapEmpResult: []\n\n// forEach方法\nvar forEachArr = [1, 2, 3, 4, 5];\nvar forEachResult = forEachArr.forEach(function(item, index, arr){ // 调用forEach()方法，返回值均为 undefined\n  console.log(this); // window\n  console.log(&apos;原始数组forEachArr：&apos;, arr); // 原始数组forEachArr： [1, 2, 3, 4, 5]\n  return item+1;\n})\nconsole.log(&apos;forEachArr:&apos;, forEachArr, &apos;; forEachResult: &apos;, forEachResult); // forEachArr: [1, 2, 3, 4, 5] ; forEachResult: undefined\n</code></pre><h6 id=\"4-数组的基本操作之-——-对数组的每一项进行操作（-filter-）\"><a href=\"#4-数组的基本操作之-——-对数组的每一项进行操作（-filter-）\" class=\"headerlink\" title=\"4. 数组的基本操作之 —— 对数组的每一项进行操作（ filter() ）\"></a>4. 数组的基本操作之 —— 对数组的每一项进行操作（ filter() ）</h6><blockquote>\n<p>说明： 遍历每一项数组，接收一个匿名函数作为参数，函数接收三个参数，参数item(遍历得到的每一项数组值)，index（索引值），arr(数组本身)， 返回一个结果为true的item组成的新数组，不会影响原数组  </p>\n</blockquote>\n<pre><code>// 需求：获取成绩合格的学生名单\nvar students = [\n  {name: &apos;张三&apos;, age: 18, scroe: 89},\n  {name: &apos;李四&apos;, age: 17, scroe: 71},\n  {name: &apos;王五&apos;, age: 18, scroe: 56},\n  {name: &apos;赵六&apos;, age: 19, scroe: 94},\n  {name: &apos;小明&apos;, age: 18, scroe: 48},\n  {name: &apos;小红&apos;, age: 19, scroe: 60},\n];\nvar studentsResult = students.filter(function(item){\n  if (item.scroe &gt;= 60) {\n    return {\n      name: item.name,\n      age: item.age,\n      score: item.scroe\n    }\n  }\n});\nconsole.log(studentsResult); // 输出如下结果\n// [{name: &quot;张三&quot;, age: 18, scroe: 89},\n// {name: &quot;李四&quot;, age: 17, scroe: 71},\n// {name: &quot;赵六&quot;, age: 19, scroe: 94},\n// {name: &quot;小红&quot;, age: 19, scroe: 60}]\n</code></pre><h6 id=\"5-数组的基本操作之-——-对数组的迭代方法-every-some-方法\"><a href=\"#5-数组的基本操作之-——-对数组的迭代方法-every-some-方法\" class=\"headerlink\" title=\"5. 数组的基本操作之 —— 对数组的迭代方法(every(), some())方法\"></a>5. 数组的基本操作之 —— 对数组的迭代方法(every(), some())方法</h6><blockquote>\n<p>说明：every()和some()都是对js中数组的迭代方法，区别如下：<br>相同点：  </p>\n<ol>\n<li>均接收一个匿名函数作为参数，函数接收三个参数，参数item(每一项),index（索引值），arr(原始数组)  </li>\n<li>均对数组的每一项运行指定的匿名函数</li>\n</ol>\n<p>不同点:<br>every(): 对数组的每一项运行给定的函数，如果该函数每一项都返回 true, 则返回 true，若存在某项返回false，则终止函数迭代，返回false; (可用来判断是不是所有，类似于逻辑 &amp;&amp;)<br>some(): 对数组的每一项运行给定的函数，如果该函数存在某一项返回 true, 函数终止，并返回 true; (可用来判断有没有，类似于逻辑 ||)</p>\n</blockquote>\n<pre><code>// 判断数组是是否全为基数\n// 使用every()方法实现\nvar everyArr1 = [1, 3, 5, 7, 9];\nvar everyArr2 = [1, 3, 5, 6, 7, 9];\nvar everyResult1 = everyArr1.every(function(item, index, arr){\n  if (!(item % 2)) {\n    console.log(&apos;第&apos;+(index+1)+&apos;项为偶数,值为：&apos;+item);\n  }\n  return item % 2;\n});\nvar everyResult2 = everyArr2.every(function(item, index, arr){\n  if (!(item % 2)) {\n    console.log(&apos;第&apos;+(index+1)+&apos;项为偶数,值为：&apos;+item); // 第4项为偶数,值为：6\n  }\n  return item % 2;\n});\nconsole.log(everyResult1?&apos;everyArr1的每一项均为基数&apos;:&apos;everyArr1的存在某一项不为基数&apos;); // everyArr的每一项均为基数\nconsole.log(everyResult2?&apos;everyArr2的每一项均为基数&apos;:&apos;everyArr2的存在某一项不为基数&apos;); // everyArr2的存在某一项不为基数\n\n// 使用some()方法实现\nvar someArr1 = [1, 3, 5, 7, 9];\nvar someArr2 = [1, 3, 5, 6, 7, 9];\nvar someResult1 = someArr1.some(function (item, index, arr) {\n  if (!(item % 2)) {\n    console.log(&apos;第&apos; + (index + 1) + &apos;项为偶数,值为：&apos; + item);\n  };\n  return !(item % 2);\n});\nvar someResult2 = someArr2.some(function (item, index, arr) {\n  if (!(item % 2)) {\n    console.log(&apos;第&apos; + (index + 1) + &apos;项为偶数,值为：&apos; + item); // 第4项为偶数,值为：6\n  };\n  return !(item % 2);\n});\nconsole.log(!someResult1 ? &apos;someArr1的每一项均为基数&apos; : &apos;someArr1的存在某一项不为基数&apos;); // someArr1的每一项均为基数\nconsole.log(!someResult2 ? &apos;someArr2的每一项均为基数&apos; : &apos;someArr2的存在某一项不为基数&apos;); // someArr2的存在某一项不为基数\n</code></pre>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjxaj7guv000sgp9a7a13sizm","category_id":"cjxaj7gux000xgp9a1s42dgbd","_id":"cjxaj7gv00014gp9arjpg881p"},{"post_id":"cjxaj7gux000ygp9aeutk0lp7","category_id":"cjxaj7gux000xgp9a1s42dgbd","_id":"cjxaj7gv00016gp9amw44n58g"}],"PostTag":[{"post_id":"cjxaj7gu40000gp9aibmk4u8l","tag_id":"cjxaj7guc0002gp9a722oweex","_id":"cjxaj7guj0007gp9ae6xx4loy"},{"post_id":"cjxaj7guj0008gp9as7ozbcj3","tag_id":"cjxaj7gui0006gp9arrswv5n2","_id":"cjxaj7gum000bgp9akz1k4nd0"},{"post_id":"cjxaj7gua0001gp9aqa1ufgdu","tag_id":"cjxaj7gui0006gp9arrswv5n2","_id":"cjxaj7gun000dgp9ax0wssya3"},{"post_id":"cjxaj7guf0003gp9avayvbjzy","tag_id":"cjxaj7gui0006gp9arrswv5n2","_id":"cjxaj7guq000hgp9a0j7or0rf"},{"post_id":"cjxaj7gun000egp9az5ebo72w","tag_id":"cjxaj7guc0002gp9a722oweex","_id":"cjxaj7gur000jgp9asvp8tk4s"},{"post_id":"cjxaj7gup000ggp9acl4zir9v","tag_id":"cjxaj7guc0002gp9a722oweex","_id":"cjxaj7gus000mgp9a0z5367k8"},{"post_id":"cjxaj7gug0004gp9aql790zfe","tag_id":"cjxaj7gui0006gp9arrswv5n2","_id":"cjxaj7gut000ogp9a1dqwz8c3"},{"post_id":"cjxaj7guh0005gp9alno8s2j9","tag_id":"cjxaj7gui0006gp9arrswv5n2","_id":"cjxaj7guu000rgp9awuoil5bc"},{"post_id":"cjxaj7gus000ngp9ajrf4jjfi","tag_id":"cjxaj7guc0002gp9a722oweex","_id":"cjxaj7guv000tgp9aw9dljntl"},{"post_id":"cjxaj7guk0009gp9ar8lff279","tag_id":"cjxaj7gut000pgp9ao19u56oq","_id":"cjxaj7gux000wgp9aimlb6dt0"},{"post_id":"cjxaj7gum000cgp9abvy6aec9","tag_id":"cjxaj7guv000ugp9a2lah4ycy","_id":"cjxaj7guz0010gp9a49n0dxm7"},{"post_id":"cjxaj7gur000lgp9ah2kq8k0p","tag_id":"cjxaj7guy000zgp9avn4fhpsf","_id":"cjxaj7gv00013gp9aptgmzw9h"},{"post_id":"cjxaj7guu000qgp9aowmunc77","tag_id":"cjxaj7gv00012gp9alf36nc4n","_id":"cjxaj7gv00017gp9a89jmzt1g"},{"post_id":"cjxaj7guv000sgp9a7a13sizm","tag_id":"cjxaj7gv00015gp9asr4tgxpv","_id":"cjxaj7gv2001cgp9aq8py3omx"},{"post_id":"cjxaj7guv000sgp9a7a13sizm","tag_id":"cjxaj7gv10018gp9akaxhuah9","_id":"cjxaj7gv2001dgp9ad5ujjytd"},{"post_id":"cjxaj7guv000sgp9a7a13sizm","tag_id":"cjxaj7gv10019gp9a09hwch0i","_id":"cjxaj7gv3001fgp9an78x3saw"},{"post_id":"cjxaj7guv000sgp9a7a13sizm","tag_id":"cjxaj7gv10018gp9akaxhuah9","_id":"cjxaj7gv3001ggp9ajum7ejqw"},{"post_id":"cjxaj7guw000vgp9amw2ltgdd","tag_id":"cjxaj7gv2001bgp9ajw605al3","_id":"cjxaj7gv3001hgp9a54chgwe6"},{"post_id":"cjxaj7gux000ygp9aeutk0lp7","tag_id":"cjxaj7gui0006gp9arrswv5n2","_id":"cjxaj7gv3001igp9aqsgxi3si"},{"post_id":"cjxaj7gux000ygp9aeutk0lp7","tag_id":"cjxaj7gv3001egp9av3vm7jwq","_id":"cjxaj7gv3001jgp9acyjtqaae"},{"post_id":"cjxaj7gv7001kgp9ah947lqt3","tag_id":"cjxaj7guc0002gp9a722oweex","_id":"cjxaj7gv9001lgp9ajakkeci3"}],"Tag":[{"name":"js","_id":"cjxaj7guc0002gp9a722oweex"},{"name":"vue","_id":"cjxaj7gui0006gp9arrswv5n2"},{"name":"Mint UI","_id":"cjxaj7gut000pgp9ao19u56oq"},{"name":"charles","_id":"cjxaj7guv000ugp9a2lah4ycy"},{"name":"Node.js","_id":"cjxaj7guy000zgp9avn4fhpsf"},{"name":"java","_id":"cjxaj7gv00012gp9alf36nc4n"},{"name":"vue-node","_id":"cjxaj7gv00015gp9asr4tgxpv"},{"name":"get","_id":"cjxaj7gv10018gp9akaxhuah9"},{"name":"post","_id":"cjxaj7gv10019gp9a09hwch0i"},{"name":"JAVA","_id":"cjxaj7gv2001bgp9ajw605al3"},{"name":"vuex","_id":"cjxaj7gv3001egp9av3vm7jwq"}]}}